"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/bnc-sdk";
exports.ids = ["vendor-chunks/bnc-sdk"];
exports.modules = {

/***/ "(ssr)/./node_modules/bnc-sdk/dist/esm/index.js":
/*!************************************************!*\
  !*** ./node_modules/bnc-sdk/dist/esm/index.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var sturdy_websocket__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! sturdy-websocket */ \"(ssr)/./node_modules/sturdy-websocket/dist/index.js\");\n/* harmony import */ var crypto_es__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! crypto-es */ \"(ssr)/./node_modules/crypto-es/lib/index.js\");\n/* harmony import */ var nanoid__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! nanoid */ \"(ssr)/./node_modules/bnc-sdk/node_modules/nanoid/index.js\");\n/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! rxjs */ \"(ssr)/./node_modules/rxjs/dist/esm5/internal/Subject.js\");\n/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! rxjs */ \"(ssr)/./node_modules/rxjs/dist/esm5/internal/observable/fromEvent.js\");\n/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! rxjs */ \"(ssr)/./node_modules/rxjs/dist/esm5/internal/observable/timer.js\");\n/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! rxjs */ \"(ssr)/./node_modules/rxjs/dist/esm5/internal/observable/merge.js\");\n\n\n\n\nconst networks = {\n  ethereum: {\n    '1': 'main',\n    '11155111': 'sepolia',\n    '100': 'xdai',\n    '137': 'matic-main',\n    '80002': 'matic-amoy'\n  }\n};\nconst DEPRECATED_NETWORK_IDS = [2, 3, 4, 42, 56, 250];\nconst DEFAULT_RATE_LIMIT_RULES = {\n  points: 150,\n  duration: 1\n};\nconst QUEUE_LIMIT = 10000;\n\nfunction validateType(options) {\n  const {\n    name,\n    value,\n    type,\n    optional,\n    customValidation\n  } = options;\n\n  if (!optional && typeof value === 'undefined') {\n    throw new Error(`\"${name}\" is required`);\n  }\n\n  if (typeof value !== 'undefined' && (type === 'array' ? Array.isArray(type) : typeof value !== type)) {\n    throw new Error(`\"${name}\" must be of type: ${type}, received type: ${typeof value} from value: ${value}`);\n  }\n\n  if (typeof value !== 'undefined' && customValidation && !customValidation(value)) {\n    throw new Error(`\"${value}\" is not a valid \"${name}\"`);\n  }\n}\n\nfunction validateOptions(options) {\n  validateType({\n    name: 'sdk options',\n    value: options,\n    type: 'object'\n  });\n  const {\n    dappId,\n    system,\n    name,\n    appVersion,\n    networkId,\n    transactionHandlers,\n    apiUrl,\n    ws,\n    onopen,\n    ondown,\n    onreopen,\n    onerror,\n    onclose,\n    ...otherParams\n  } = options;\n  invalidParams(otherParams, ['dappId', 'system', 'name', 'appVersion', 'networkId', 'transactionHandlers', 'apiUrl', 'ws', 'onopen', 'ondown', 'onreopen', 'onerror', 'onclose'], 'Initialization Options');\n  validateType({\n    name: 'dappId',\n    value: dappId,\n    type: 'string',\n    optional: true\n  });\n  validateType({\n    name: 'system',\n    value: system,\n    type: 'string',\n    optional: true,\n    customValidation: validSystem\n  });\n  validateType({\n    name: 'name',\n    value: name,\n    type: 'string',\n    optional: true\n  });\n  validateType({\n    name: 'appVersion',\n    value: appVersion,\n    type: 'string',\n    optional: true\n  });\n  validateType({\n    name: 'networkId',\n    value: networkId,\n    type: 'number'\n  });\n\n  if (DEPRECATED_NETWORK_IDS.includes(networkId)) {\n    console.error(`Blocknative SDK: Network with ID: ${networkId} has been deprecated and you will no longer receive transaction events on this network.`);\n  }\n\n  validateType({\n    name: 'transactionHandler',\n    value: transactionHandlers,\n    type: 'array',\n    optional: true\n  });\n\n  if (transactionHandlers) {\n    transactionHandlers.forEach(handler => validateType({\n      name: 'transactionHandler',\n      value: handler,\n      type: 'function'\n    }));\n  }\n\n  validateType({\n    name: 'apiUrl',\n    value: apiUrl,\n    type: 'string',\n    optional: true\n  });\n  validateType({\n    name: 'ws',\n    value: ws,\n    type: 'function',\n    optional: true\n  });\n  validateType({\n    name: 'onopen',\n    value: onopen,\n    type: 'function',\n    optional: true\n  });\n  validateType({\n    name: 'ondown',\n    value: ondown,\n    type: 'function',\n    optional: true\n  });\n  validateType({\n    name: 'onreopen',\n    value: onreopen,\n    type: 'function',\n    optional: true\n  });\n  validateType({\n    name: 'onerror',\n    value: onerror,\n    type: 'function',\n    optional: true\n  });\n  validateType({\n    name: 'onclose',\n    value: onclose,\n    type: 'function',\n    optional: true\n  });\n}\n\nfunction validSystem(system) {\n  return !!networks[system];\n}\n\nfunction invalidParams(params, validParams, functionName) {\n  const invalid = Object.keys(params);\n\n  if (invalid.length > 0) {\n    throw new Error(`${invalid[0]} is not a valid parameter for ${functionName}, must be one of the following valid parameters: ${validParams.join(', ')}`);\n  }\n}\n\nfunction createEmitter() {\n  return {\n    listeners: {},\n    on: function (eventCode, listener) {\n      // check if valid eventCode\n      switch (eventCode) {\n        case 'txSent':\n        case 'txPool':\n        case 'txConfirmed':\n        case 'txSpeedUp':\n        case 'txCancel':\n        case 'txFailed':\n        case 'txDropped':\n        case 'txRequest':\n        case 'nsfFail':\n        case 'txRepeat':\n        case 'txAwaitingApproval':\n        case 'txConfirmReminder':\n        case 'txSendFail':\n        case 'txError':\n        case 'txUnderPriced':\n        case 'txPoolSimulation':\n        case 'all':\n          break;\n\n        default:\n          throw new Error(`${eventCode} is not a valid event code, for a list of valid event codes see: https://docs.blocknative.com/notify-sdk#event-codes`);\n      } // check that listener is a function\n\n\n      if (typeof listener !== 'function') {\n        throw new Error('Listener must be a function');\n      } // add listener for the eventCode\n\n\n      this.listeners[eventCode] = listener;\n    },\n    off: function (eventCode) {\n      delete this.listeners[eventCode];\n    },\n    emit: function (state) {\n      if (this.listeners[state.eventCode]) {\n        return this.listeners[state.eventCode](state);\n      }\n\n      if (this.listeners.all) {\n        return this.listeners.all(state);\n      }\n    }\n  };\n}\n\nfunction networkName(blockchain, id) {\n  return networks[blockchain][id];\n}\n\nfunction serverEcho(eventCode) {\n  switch (eventCode) {\n    case 'txRequest':\n    case 'nsfFail':\n    case 'txRepeat':\n    case 'txAwaitingApproval':\n    case 'txConfirmReminder':\n    case 'txSendFail':\n    case 'txError':\n    case 'txUnderPriced':\n    case 'txSent':\n      return true;\n\n    default:\n      return false;\n  }\n}\n\nfunction last(arr) {\n  return arr.reverse()[0];\n} // isAddress and isTxid are not meant to perform real validation,\n// just needs to work out if it is an address or a transaction id\n// the server will do more thorough validation\n\n\nfunction isAddress(blockchain, addressOrHash) {\n  switch (blockchain) {\n    case 'ethereum':\n      return addressOrHash.length === 42;\n\n    case 'bitcoin':\n      return addressOrHash.length !== 64;\n\n    default:\n      return false;\n  }\n}\n\nfunction isTxid(blockchain, addressOrHash) {\n  switch (blockchain) {\n    case 'ethereum':\n      return addressOrHash.length === 66;\n\n    case 'bitcoin':\n      return addressOrHash.length === 64;\n\n    default:\n      return false;\n  }\n}\n\nfunction wait(time) {\n  return new Promise(resolve => {\n    setTimeout(resolve, time);\n  });\n}\n\nconst jsonPreserveUndefined = (k, v) => v === undefined ? 'undefined' : v;\n/**\r\n * Tests if LocalStorage may be used. Accounts for environments where\r\n * LocalStorage is not supported, as well as those where it is blocked.\r\n *\r\n * @returns `true` if LocalStorage is supported and accessible, `false` otherwise.\r\n */\n\n\nfunction isLocalStorageAvailable() {\n  const isSupported = typeof window !== 'undefined' && 'localStorage' in window;\n\n  if (isSupported) {\n    const testKey = '__testLocalStorage';\n\n    try {\n      window.localStorage.setItem(testKey, '1');\n      window.localStorage.removeItem(testKey);\n      return true;\n    } catch (err) {\n      return false;\n    }\n  }\n\n  return false;\n}\n\nfunction transaction(hash, id) {\n  if (this._destroyed) throw new Error('The WebSocket instance has been destroyed, re-initialize to continue making requests.'); // create startTime for transaction\n\n  const startTime = Date.now(); // create emitter for transaction\n\n  const emitter = createEmitter(); // create eventCode for transaction\n\n  const eventCode = 'txSent'; // put in queue\n\n  this.watchedTransactions.push({\n    hash,\n    emitter\n  });\n  const transactionId = this._system === 'ethereum' ? {\n    hash\n  } : {\n    txid: hash\n  };\n  const transaction = { ...transactionId,\n    id: id || hash,\n    startTime,\n    status: 'sent'\n  };\n  const newState = { ...transaction,\n    eventCode\n  }; // logEvent to server\n\n  this._sendMessage({\n    eventCode,\n    categoryCode: 'activeTransaction',\n    transaction\n  });\n\n  const transactionObj = {\n    details: newState,\n    emitter\n  };\n\n  function emitState() {\n    const emitterResult = emitter.emit(newState);\n\n    this._transactionHandlers.forEach(handler => handler({\n      transaction: newState,\n      emitterResult\n    }));\n  } // emit after delay to allow for listener to be registered\n\n\n  setTimeout(emitState.bind(this), 5);\n  return transactionObj;\n}\n\nfunction account(address) {\n  if (this._destroyed) throw new Error('The WebSocket instance has been destroyed, re-initialize to continue making requests.'); // lowercase the address if Ethereum\n\n  address = this._system === 'ethereum' ? address.toLowerCase() : address; // create emitter for transaction\n\n  const emitter = createEmitter(); // create eventCode for transaction\n\n  const eventCode = 'watch';\n  const existingAddressWatcher = this.watchedAccounts.find(ac => ac.address === address);\n\n  if (existingAddressWatcher) {\n    // add to existing emitters array\n    existingAddressWatcher.emitters.push(emitter);\n  } else {\n    // put in accounts queue\n    this.watchedAccounts.push({\n      address,\n      emitters: [emitter]\n    });\n  } // logEvent to server\n\n\n  this._sendMessage({\n    eventCode,\n    categoryCode: 'accountAddress',\n    account: {\n      address\n    }\n  });\n\n  return {\n    emitter,\n    details: {\n      address\n    }\n  };\n}\n\nfunction event(eventObj) {\n  if (this._destroyed) throw new Error('The WebSocket instance has been destroyed, re-initialize to continue making requests.');\n\n  this._sendMessage(eventObj);\n}\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\n\n/* global Reflect, Promise */\n\n\nvar extendStatics = function (d, b) {\n  extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n  };\n\n  return extendStatics(d, b);\n};\n\nfunction __extends(d, b) {\n  extendStatics(d, b);\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\n/** PURE_IMPORTS_START  PURE_IMPORTS_END */\n\n\nfunction isFunction(x) {\n  return typeof x === 'function';\n}\n/** PURE_IMPORTS_START  PURE_IMPORTS_END */\n\n\nvar _enable_super_gross_mode_that_will_cause_bad_things = false;\nvar config = {\n  Promise: undefined,\n\n  set useDeprecatedSynchronousErrorHandling(value) {\n    if (value) {\n      var error = /*@__PURE__*/new Error();\n      /*@__PURE__*/\n\n      console.warn('DEPRECATED! RxJS was set to use deprecated synchronous error handling behavior by code at: \\n' + error.stack);\n    }\n\n    _enable_super_gross_mode_that_will_cause_bad_things = value;\n  },\n\n  get useDeprecatedSynchronousErrorHandling() {\n    return _enable_super_gross_mode_that_will_cause_bad_things;\n  }\n\n};\n/** PURE_IMPORTS_START  PURE_IMPORTS_END */\n\nfunction hostReportError(err) {\n  setTimeout(function () {\n    throw err;\n  }, 0);\n}\n/** PURE_IMPORTS_START _config,_util_hostReportError PURE_IMPORTS_END */\n\n\nvar empty = {\n  closed: true,\n  next: function (value) {},\n  error: function (err) {\n    if (config.useDeprecatedSynchronousErrorHandling) {\n      throw err;\n    } else {\n      hostReportError(err);\n    }\n  },\n  complete: function () {}\n};\n/** PURE_IMPORTS_START  PURE_IMPORTS_END */\n\nvar isArray = /*@__PURE__*/function () {\n  return Array.isArray || function (x) {\n    return x && typeof x.length === 'number';\n  };\n}();\n/** PURE_IMPORTS_START  PURE_IMPORTS_END */\n\n\nfunction isObject(x) {\n  return x !== null && typeof x === 'object';\n}\n/** PURE_IMPORTS_START  PURE_IMPORTS_END */\n\n\nvar UnsubscriptionErrorImpl = /*@__PURE__*/function () {\n  function UnsubscriptionErrorImpl(errors) {\n    Error.call(this);\n    this.message = errors ? errors.length + \" errors occurred during unsubscription:\\n\" + errors.map(function (err, i) {\n      return i + 1 + \") \" + err.toString();\n    }).join('\\n  ') : '';\n    this.name = 'UnsubscriptionError';\n    this.errors = errors;\n    return this;\n  }\n\n  UnsubscriptionErrorImpl.prototype = /*@__PURE__*/Object.create(Error.prototype);\n  return UnsubscriptionErrorImpl;\n}();\n\nvar UnsubscriptionError = UnsubscriptionErrorImpl;\n/** PURE_IMPORTS_START _util_isArray,_util_isObject,_util_isFunction,_util_UnsubscriptionError PURE_IMPORTS_END */\n\nvar Subscription = /*@__PURE__*/function () {\n  function Subscription(unsubscribe) {\n    this.closed = false;\n    this._parentOrParents = null;\n    this._subscriptions = null;\n\n    if (unsubscribe) {\n      this._ctorUnsubscribe = true;\n      this._unsubscribe = unsubscribe;\n    }\n  }\n\n  Subscription.prototype.unsubscribe = function () {\n    var errors;\n\n    if (this.closed) {\n      return;\n    }\n\n    var _a = this,\n        _parentOrParents = _a._parentOrParents,\n        _ctorUnsubscribe = _a._ctorUnsubscribe,\n        _unsubscribe = _a._unsubscribe,\n        _subscriptions = _a._subscriptions;\n\n    this.closed = true;\n    this._parentOrParents = null;\n    this._subscriptions = null;\n\n    if (_parentOrParents instanceof Subscription) {\n      _parentOrParents.remove(this);\n    } else if (_parentOrParents !== null) {\n      for (var index = 0; index < _parentOrParents.length; ++index) {\n        var parent_1 = _parentOrParents[index];\n        parent_1.remove(this);\n      }\n    }\n\n    if (isFunction(_unsubscribe)) {\n      if (_ctorUnsubscribe) {\n        this._unsubscribe = undefined;\n      }\n\n      try {\n        _unsubscribe.call(this);\n      } catch (e) {\n        errors = e instanceof UnsubscriptionError ? flattenUnsubscriptionErrors(e.errors) : [e];\n      }\n    }\n\n    if (isArray(_subscriptions)) {\n      var index = -1;\n      var len = _subscriptions.length;\n\n      while (++index < len) {\n        var sub = _subscriptions[index];\n\n        if (isObject(sub)) {\n          try {\n            sub.unsubscribe();\n          } catch (e) {\n            errors = errors || [];\n\n            if (e instanceof UnsubscriptionError) {\n              errors = errors.concat(flattenUnsubscriptionErrors(e.errors));\n            } else {\n              errors.push(e);\n            }\n          }\n        }\n      }\n    }\n\n    if (errors) {\n      throw new UnsubscriptionError(errors);\n    }\n  };\n\n  Subscription.prototype.add = function (teardown) {\n    var subscription = teardown;\n\n    if (!teardown) {\n      return Subscription.EMPTY;\n    }\n\n    switch (typeof teardown) {\n      case 'function':\n        subscription = new Subscription(teardown);\n\n      case 'object':\n        if (subscription === this || subscription.closed || typeof subscription.unsubscribe !== 'function') {\n          return subscription;\n        } else if (this.closed) {\n          subscription.unsubscribe();\n          return subscription;\n        } else if (!(subscription instanceof Subscription)) {\n          var tmp = subscription;\n          subscription = new Subscription();\n          subscription._subscriptions = [tmp];\n        }\n\n        break;\n\n      default:\n        {\n          throw new Error('unrecognized teardown ' + teardown + ' added to Subscription.');\n        }\n    }\n\n    var _parentOrParents = subscription._parentOrParents;\n\n    if (_parentOrParents === null) {\n      subscription._parentOrParents = this;\n    } else if (_parentOrParents instanceof Subscription) {\n      if (_parentOrParents === this) {\n        return subscription;\n      }\n\n      subscription._parentOrParents = [_parentOrParents, this];\n    } else if (_parentOrParents.indexOf(this) === -1) {\n      _parentOrParents.push(this);\n    } else {\n      return subscription;\n    }\n\n    var subscriptions = this._subscriptions;\n\n    if (subscriptions === null) {\n      this._subscriptions = [subscription];\n    } else {\n      subscriptions.push(subscription);\n    }\n\n    return subscription;\n  };\n\n  Subscription.prototype.remove = function (subscription) {\n    var subscriptions = this._subscriptions;\n\n    if (subscriptions) {\n      var subscriptionIndex = subscriptions.indexOf(subscription);\n\n      if (subscriptionIndex !== -1) {\n        subscriptions.splice(subscriptionIndex, 1);\n      }\n    }\n  };\n\n  Subscription.EMPTY = function (empty) {\n    empty.closed = true;\n    return empty;\n  }(new Subscription());\n\n  return Subscription;\n}();\n\nfunction flattenUnsubscriptionErrors(errors) {\n  return errors.reduce(function (errs, err) {\n    return errs.concat(err instanceof UnsubscriptionError ? err.errors : err);\n  }, []);\n}\n/** PURE_IMPORTS_START  PURE_IMPORTS_END */\n\n\nvar rxSubscriber = /*@__PURE__*/function () {\n  return typeof Symbol === 'function' ? /*@__PURE__*/Symbol('rxSubscriber') : '@@rxSubscriber_' + /*@__PURE__*/Math.random();\n}();\n/** PURE_IMPORTS_START tslib,_util_isFunction,_Observer,_Subscription,_internal_symbol_rxSubscriber,_config,_util_hostReportError PURE_IMPORTS_END */\n\n\nvar Subscriber = /*@__PURE__*/function (_super) {\n  __extends(Subscriber, _super);\n\n  function Subscriber(destinationOrNext, error, complete) {\n    var _this = _super.call(this) || this;\n\n    _this.syncErrorValue = null;\n    _this.syncErrorThrown = false;\n    _this.syncErrorThrowable = false;\n    _this.isStopped = false;\n\n    switch (arguments.length) {\n      case 0:\n        _this.destination = empty;\n        break;\n\n      case 1:\n        if (!destinationOrNext) {\n          _this.destination = empty;\n          break;\n        }\n\n        if (typeof destinationOrNext === 'object') {\n          if (destinationOrNext instanceof Subscriber) {\n            _this.syncErrorThrowable = destinationOrNext.syncErrorThrowable;\n            _this.destination = destinationOrNext;\n            destinationOrNext.add(_this);\n          } else {\n            _this.syncErrorThrowable = true;\n            _this.destination = new SafeSubscriber(_this, destinationOrNext);\n          }\n\n          break;\n        }\n\n      default:\n        _this.syncErrorThrowable = true;\n        _this.destination = new SafeSubscriber(_this, destinationOrNext, error, complete);\n        break;\n    }\n\n    return _this;\n  }\n\n  Subscriber.prototype[rxSubscriber] = function () {\n    return this;\n  };\n\n  Subscriber.create = function (next, error, complete) {\n    var subscriber = new Subscriber(next, error, complete);\n    subscriber.syncErrorThrowable = false;\n    return subscriber;\n  };\n\n  Subscriber.prototype.next = function (value) {\n    if (!this.isStopped) {\n      this._next(value);\n    }\n  };\n\n  Subscriber.prototype.error = function (err) {\n    if (!this.isStopped) {\n      this.isStopped = true;\n\n      this._error(err);\n    }\n  };\n\n  Subscriber.prototype.complete = function () {\n    if (!this.isStopped) {\n      this.isStopped = true;\n\n      this._complete();\n    }\n  };\n\n  Subscriber.prototype.unsubscribe = function () {\n    if (this.closed) {\n      return;\n    }\n\n    this.isStopped = true;\n\n    _super.prototype.unsubscribe.call(this);\n  };\n\n  Subscriber.prototype._next = function (value) {\n    this.destination.next(value);\n  };\n\n  Subscriber.prototype._error = function (err) {\n    this.destination.error(err);\n    this.unsubscribe();\n  };\n\n  Subscriber.prototype._complete = function () {\n    this.destination.complete();\n    this.unsubscribe();\n  };\n\n  Subscriber.prototype._unsubscribeAndRecycle = function () {\n    var _parentOrParents = this._parentOrParents;\n    this._parentOrParents = null;\n    this.unsubscribe();\n    this.closed = false;\n    this.isStopped = false;\n    this._parentOrParents = _parentOrParents;\n    return this;\n  };\n\n  return Subscriber;\n}(Subscription);\n\nvar SafeSubscriber = /*@__PURE__*/function (_super) {\n  __extends(SafeSubscriber, _super);\n\n  function SafeSubscriber(_parentSubscriber, observerOrNext, error, complete) {\n    var _this = _super.call(this) || this;\n\n    _this._parentSubscriber = _parentSubscriber;\n    var next;\n    var context = _this;\n\n    if (isFunction(observerOrNext)) {\n      next = observerOrNext;\n    } else if (observerOrNext) {\n      next = observerOrNext.next;\n      error = observerOrNext.error;\n      complete = observerOrNext.complete;\n\n      if (observerOrNext !== empty) {\n        context = Object.create(observerOrNext);\n\n        if (isFunction(context.unsubscribe)) {\n          _this.add(context.unsubscribe.bind(context));\n        }\n\n        context.unsubscribe = _this.unsubscribe.bind(_this);\n      }\n    }\n\n    _this._context = context;\n    _this._next = next;\n    _this._error = error;\n    _this._complete = complete;\n    return _this;\n  }\n\n  SafeSubscriber.prototype.next = function (value) {\n    if (!this.isStopped && this._next) {\n      var _parentSubscriber = this._parentSubscriber;\n\n      if (!config.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {\n        this.__tryOrUnsub(this._next, value);\n      } else if (this.__tryOrSetError(_parentSubscriber, this._next, value)) {\n        this.unsubscribe();\n      }\n    }\n  };\n\n  SafeSubscriber.prototype.error = function (err) {\n    if (!this.isStopped) {\n      var _parentSubscriber = this._parentSubscriber;\n      var useDeprecatedSynchronousErrorHandling = config.useDeprecatedSynchronousErrorHandling;\n\n      if (this._error) {\n        if (!useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {\n          this.__tryOrUnsub(this._error, err);\n\n          this.unsubscribe();\n        } else {\n          this.__tryOrSetError(_parentSubscriber, this._error, err);\n\n          this.unsubscribe();\n        }\n      } else if (!_parentSubscriber.syncErrorThrowable) {\n        this.unsubscribe();\n\n        if (useDeprecatedSynchronousErrorHandling) {\n          throw err;\n        }\n\n        hostReportError(err);\n      } else {\n        if (useDeprecatedSynchronousErrorHandling) {\n          _parentSubscriber.syncErrorValue = err;\n          _parentSubscriber.syncErrorThrown = true;\n        } else {\n          hostReportError(err);\n        }\n\n        this.unsubscribe();\n      }\n    }\n  };\n\n  SafeSubscriber.prototype.complete = function () {\n    var _this = this;\n\n    if (!this.isStopped) {\n      var _parentSubscriber = this._parentSubscriber;\n\n      if (this._complete) {\n        var wrappedComplete = function () {\n          return _this._complete.call(_this._context);\n        };\n\n        if (!config.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {\n          this.__tryOrUnsub(wrappedComplete);\n\n          this.unsubscribe();\n        } else {\n          this.__tryOrSetError(_parentSubscriber, wrappedComplete);\n\n          this.unsubscribe();\n        }\n      } else {\n        this.unsubscribe();\n      }\n    }\n  };\n\n  SafeSubscriber.prototype.__tryOrUnsub = function (fn, value) {\n    try {\n      fn.call(this._context, value);\n    } catch (err) {\n      this.unsubscribe();\n\n      if (config.useDeprecatedSynchronousErrorHandling) {\n        throw err;\n      } else {\n        hostReportError(err);\n      }\n    }\n  };\n\n  SafeSubscriber.prototype.__tryOrSetError = function (parent, fn, value) {\n    if (!config.useDeprecatedSynchronousErrorHandling) {\n      throw new Error('bad call');\n    }\n\n    try {\n      fn.call(this._context, value);\n    } catch (err) {\n      if (config.useDeprecatedSynchronousErrorHandling) {\n        parent.syncErrorValue = err;\n        parent.syncErrorThrown = true;\n        return true;\n      } else {\n        hostReportError(err);\n        return true;\n      }\n    }\n\n    return false;\n  };\n\n  SafeSubscriber.prototype._unsubscribe = function () {\n    var _parentSubscriber = this._parentSubscriber;\n    this._context = null;\n    this._parentSubscriber = null;\n\n    _parentSubscriber.unsubscribe();\n  };\n\n  return SafeSubscriber;\n}(Subscriber);\n/** PURE_IMPORTS_START _Subscriber PURE_IMPORTS_END */\n\n\nfunction canReportError(observer) {\n  while (observer) {\n    var _a = observer,\n        closed_1 = _a.closed,\n        destination = _a.destination,\n        isStopped = _a.isStopped;\n\n    if (closed_1 || isStopped) {\n      return false;\n    } else if (destination && destination instanceof Subscriber) {\n      observer = destination;\n    } else {\n      observer = null;\n    }\n  }\n\n  return true;\n}\n/** PURE_IMPORTS_START _Subscriber,_symbol_rxSubscriber,_Observer PURE_IMPORTS_END */\n\n\nfunction toSubscriber(nextOrObserver, error, complete) {\n  if (nextOrObserver) {\n    if (nextOrObserver instanceof Subscriber) {\n      return nextOrObserver;\n    }\n\n    if (nextOrObserver[rxSubscriber]) {\n      return nextOrObserver[rxSubscriber]();\n    }\n  }\n\n  if (!nextOrObserver && !error && !complete) {\n    return new Subscriber(empty);\n  }\n\n  return new Subscriber(nextOrObserver, error, complete);\n}\n/** PURE_IMPORTS_START  PURE_IMPORTS_END */\n\n\nvar observable = /*@__PURE__*/function () {\n  return typeof Symbol === 'function' && Symbol.observable || '@@observable';\n}();\n/** PURE_IMPORTS_START  PURE_IMPORTS_END */\n\n\nfunction identity(x) {\n  return x;\n}\n/** PURE_IMPORTS_START _identity PURE_IMPORTS_END */\n\n\nfunction pipeFromArray(fns) {\n  if (fns.length === 0) {\n    return identity;\n  }\n\n  if (fns.length === 1) {\n    return fns[0];\n  }\n\n  return function piped(input) {\n    return fns.reduce(function (prev, fn) {\n      return fn(prev);\n    }, input);\n  };\n}\n/** PURE_IMPORTS_START _util_canReportError,_util_toSubscriber,_symbol_observable,_util_pipe,_config PURE_IMPORTS_END */\n\n\nvar Observable = /*@__PURE__*/function () {\n  function Observable(subscribe) {\n    this._isScalar = false;\n\n    if (subscribe) {\n      this._subscribe = subscribe;\n    }\n  }\n\n  Observable.prototype.lift = function (operator) {\n    var observable = new Observable();\n    observable.source = this;\n    observable.operator = operator;\n    return observable;\n  };\n\n  Observable.prototype.subscribe = function (observerOrNext, error, complete) {\n    var operator = this.operator;\n    var sink = toSubscriber(observerOrNext, error, complete);\n\n    if (operator) {\n      sink.add(operator.call(sink, this.source));\n    } else {\n      sink.add(this.source || config.useDeprecatedSynchronousErrorHandling && !sink.syncErrorThrowable ? this._subscribe(sink) : this._trySubscribe(sink));\n    }\n\n    if (config.useDeprecatedSynchronousErrorHandling) {\n      if (sink.syncErrorThrowable) {\n        sink.syncErrorThrowable = false;\n\n        if (sink.syncErrorThrown) {\n          throw sink.syncErrorValue;\n        }\n      }\n    }\n\n    return sink;\n  };\n\n  Observable.prototype._trySubscribe = function (sink) {\n    try {\n      return this._subscribe(sink);\n    } catch (err) {\n      if (config.useDeprecatedSynchronousErrorHandling) {\n        sink.syncErrorThrown = true;\n        sink.syncErrorValue = err;\n      }\n\n      if (canReportError(sink)) {\n        sink.error(err);\n      } else {\n        console.warn(err);\n      }\n    }\n  };\n\n  Observable.prototype.forEach = function (next, promiseCtor) {\n    var _this = this;\n\n    promiseCtor = getPromiseCtor(promiseCtor);\n    return new promiseCtor(function (resolve, reject) {\n      var subscription;\n      subscription = _this.subscribe(function (value) {\n        try {\n          next(value);\n        } catch (err) {\n          reject(err);\n\n          if (subscription) {\n            subscription.unsubscribe();\n          }\n        }\n      }, reject, resolve);\n    });\n  };\n\n  Observable.prototype._subscribe = function (subscriber) {\n    var source = this.source;\n    return source && source.subscribe(subscriber);\n  };\n\n  Observable.prototype[observable] = function () {\n    return this;\n  };\n\n  Observable.prototype.pipe = function () {\n    var operations = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      operations[_i] = arguments[_i];\n    }\n\n    if (operations.length === 0) {\n      return this;\n    }\n\n    return pipeFromArray(operations)(this);\n  };\n\n  Observable.prototype.toPromise = function (promiseCtor) {\n    var _this = this;\n\n    promiseCtor = getPromiseCtor(promiseCtor);\n    return new promiseCtor(function (resolve, reject) {\n      var value;\n\n      _this.subscribe(function (x) {\n        return value = x;\n      }, function (err) {\n        return reject(err);\n      }, function () {\n        return resolve(value);\n      });\n    });\n  };\n\n  Observable.create = function (subscribe) {\n    return new Observable(subscribe);\n  };\n\n  return Observable;\n}();\n\nfunction getPromiseCtor(promiseCtor) {\n  if (!promiseCtor) {\n    promiseCtor = Promise;\n  }\n\n  if (!promiseCtor) {\n    throw new Error('no Promise impl found');\n  }\n\n  return promiseCtor;\n}\n/** PURE_IMPORTS_START  PURE_IMPORTS_END */\n\n\nvar subscribeToArray = function (array) {\n  return function (subscriber) {\n    for (var i = 0, len = array.length; i < len && !subscriber.closed; i++) {\n      subscriber.next(array[i]);\n    }\n\n    subscriber.complete();\n  };\n};\n/** PURE_IMPORTS_START _hostReportError PURE_IMPORTS_END */\n\n\nvar subscribeToPromise = function (promise) {\n  return function (subscriber) {\n    promise.then(function (value) {\n      if (!subscriber.closed) {\n        subscriber.next(value);\n        subscriber.complete();\n      }\n    }, function (err) {\n      return subscriber.error(err);\n    }).then(null, hostReportError);\n    return subscriber;\n  };\n};\n/** PURE_IMPORTS_START  PURE_IMPORTS_END */\n\n\nfunction getSymbolIterator() {\n  if (typeof Symbol !== 'function' || !Symbol.iterator) {\n    return '@@iterator';\n  }\n\n  return Symbol.iterator;\n}\n\nvar iterator = /*@__PURE__*/getSymbolIterator();\n/** PURE_IMPORTS_START _symbol_iterator PURE_IMPORTS_END */\n\nvar subscribeToIterable = function (iterable) {\n  return function (subscriber) {\n    var iterator$1 = iterable[iterator]();\n\n    do {\n      var item = void 0;\n\n      try {\n        item = iterator$1.next();\n      } catch (err) {\n        subscriber.error(err);\n        return subscriber;\n      }\n\n      if (item.done) {\n        subscriber.complete();\n        break;\n      }\n\n      subscriber.next(item.value);\n\n      if (subscriber.closed) {\n        break;\n      }\n    } while (true);\n\n    if (typeof iterator$1.return === 'function') {\n      subscriber.add(function () {\n        if (iterator$1.return) {\n          iterator$1.return();\n        }\n      });\n    }\n\n    return subscriber;\n  };\n};\n/** PURE_IMPORTS_START _symbol_observable PURE_IMPORTS_END */\n\n\nvar subscribeToObservable = function (obj) {\n  return function (subscriber) {\n    var obs = obj[observable]();\n\n    if (typeof obs.subscribe !== 'function') {\n      throw new TypeError('Provided object does not correctly implement Symbol.observable');\n    } else {\n      return obs.subscribe(subscriber);\n    }\n  };\n};\n/** PURE_IMPORTS_START  PURE_IMPORTS_END */\n\n\nvar isArrayLike = function (x) {\n  return x && typeof x.length === 'number' && typeof x !== 'function';\n};\n/** PURE_IMPORTS_START  PURE_IMPORTS_END */\n\n\nfunction isPromise(value) {\n  return !!value && typeof value.subscribe !== 'function' && typeof value.then === 'function';\n}\n/** PURE_IMPORTS_START _subscribeToArray,_subscribeToPromise,_subscribeToIterable,_subscribeToObservable,_isArrayLike,_isPromise,_isObject,_symbol_iterator,_symbol_observable PURE_IMPORTS_END */\n\n\nvar subscribeTo = function (result) {\n  if (!!result && typeof result[observable] === 'function') {\n    return subscribeToObservable(result);\n  } else if (isArrayLike(result)) {\n    return subscribeToArray(result);\n  } else if (isPromise(result)) {\n    return subscribeToPromise(result);\n  } else if (!!result && typeof result[iterator] === 'function') {\n    return subscribeToIterable(result);\n  } else {\n    var value = isObject(result) ? 'an invalid object' : \"'\" + result + \"'\";\n    var msg = \"You provided \" + value + \" where a stream was expected.\" + ' You can provide an Observable, Promise, Array, or Iterable.';\n    throw new TypeError(msg);\n  }\n};\n/** PURE_IMPORTS_START tslib,_Subscriber,_Observable,_util_subscribeTo PURE_IMPORTS_END */\n\n\nvar SimpleInnerSubscriber = /*@__PURE__*/function (_super) {\n  __extends(SimpleInnerSubscriber, _super);\n\n  function SimpleInnerSubscriber(parent) {\n    var _this = _super.call(this) || this;\n\n    _this.parent = parent;\n    return _this;\n  }\n\n  SimpleInnerSubscriber.prototype._next = function (value) {\n    this.parent.notifyNext(value);\n  };\n\n  SimpleInnerSubscriber.prototype._error = function (error) {\n    this.parent.notifyError(error);\n    this.unsubscribe();\n  };\n\n  SimpleInnerSubscriber.prototype._complete = function () {\n    this.parent.notifyComplete();\n    this.unsubscribe();\n  };\n\n  return SimpleInnerSubscriber;\n}(Subscriber);\n\nvar SimpleOuterSubscriber = /*@__PURE__*/function (_super) {\n  __extends(SimpleOuterSubscriber, _super);\n\n  function SimpleOuterSubscriber() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  SimpleOuterSubscriber.prototype.notifyNext = function (innerValue) {\n    this.destination.next(innerValue);\n  };\n\n  SimpleOuterSubscriber.prototype.notifyError = function (err) {\n    this.destination.error(err);\n  };\n\n  SimpleOuterSubscriber.prototype.notifyComplete = function () {\n    this.destination.complete();\n  };\n\n  return SimpleOuterSubscriber;\n}(Subscriber);\n\nfunction innerSubscribe(result, innerSubscriber) {\n  if (innerSubscriber.closed) {\n    return undefined;\n  }\n\n  if (result instanceof Observable) {\n    return result.subscribe(innerSubscriber);\n  }\n\n  return subscribeTo(result)(innerSubscriber);\n}\n/** PURE_IMPORTS_START tslib,_Subscription PURE_IMPORTS_END */\n\n\nvar Action = /*@__PURE__*/function (_super) {\n  __extends(Action, _super);\n\n  function Action(scheduler, work) {\n    return _super.call(this) || this;\n  }\n\n  Action.prototype.schedule = function (state, delay) {\n    return this;\n  };\n\n  return Action;\n}(Subscription);\n/** PURE_IMPORTS_START tslib,_Action PURE_IMPORTS_END */\n\n\nvar AsyncAction = /*@__PURE__*/function (_super) {\n  __extends(AsyncAction, _super);\n\n  function AsyncAction(scheduler, work) {\n    var _this = _super.call(this, scheduler, work) || this;\n\n    _this.scheduler = scheduler;\n    _this.work = work;\n    _this.pending = false;\n    return _this;\n  }\n\n  AsyncAction.prototype.schedule = function (state, delay) {\n    if (delay === void 0) {\n      delay = 0;\n    }\n\n    if (this.closed) {\n      return this;\n    }\n\n    this.state = state;\n    var id = this.id;\n    var scheduler = this.scheduler;\n\n    if (id != null) {\n      this.id = this.recycleAsyncId(scheduler, id, delay);\n    }\n\n    this.pending = true;\n    this.delay = delay;\n    this.id = this.id || this.requestAsyncId(scheduler, this.id, delay);\n    return this;\n  };\n\n  AsyncAction.prototype.requestAsyncId = function (scheduler, id, delay) {\n    if (delay === void 0) {\n      delay = 0;\n    }\n\n    return setInterval(scheduler.flush.bind(scheduler, this), delay);\n  };\n\n  AsyncAction.prototype.recycleAsyncId = function (scheduler, id, delay) {\n    if (delay === void 0) {\n      delay = 0;\n    }\n\n    if (delay !== null && this.delay === delay && this.pending === false) {\n      return id;\n    }\n\n    clearInterval(id);\n    return undefined;\n  };\n\n  AsyncAction.prototype.execute = function (state, delay) {\n    if (this.closed) {\n      return new Error('executing a cancelled action');\n    }\n\n    this.pending = false;\n\n    var error = this._execute(state, delay);\n\n    if (error) {\n      return error;\n    } else if (this.pending === false && this.id != null) {\n      this.id = this.recycleAsyncId(this.scheduler, this.id, null);\n    }\n  };\n\n  AsyncAction.prototype._execute = function (state, delay) {\n    var errored = false;\n    var errorValue = undefined;\n\n    try {\n      this.work(state);\n    } catch (e) {\n      errored = true;\n      errorValue = !!e && e || new Error(e);\n    }\n\n    if (errored) {\n      this.unsubscribe();\n      return errorValue;\n    }\n  };\n\n  AsyncAction.prototype._unsubscribe = function () {\n    var id = this.id;\n    var scheduler = this.scheduler;\n    var actions = scheduler.actions;\n    var index = actions.indexOf(this);\n    this.work = null;\n    this.state = null;\n    this.pending = false;\n    this.scheduler = null;\n\n    if (index !== -1) {\n      actions.splice(index, 1);\n    }\n\n    if (id != null) {\n      this.id = this.recycleAsyncId(scheduler, id, null);\n    }\n\n    this.delay = null;\n  };\n\n  return AsyncAction;\n}(Action);\n\nvar Scheduler = /*@__PURE__*/function () {\n  function Scheduler(SchedulerAction, now) {\n    if (now === void 0) {\n      now = Scheduler.now;\n    }\n\n    this.SchedulerAction = SchedulerAction;\n    this.now = now;\n  }\n\n  Scheduler.prototype.schedule = function (work, delay, state) {\n    if (delay === void 0) {\n      delay = 0;\n    }\n\n    return new this.SchedulerAction(this, work).schedule(state, delay);\n  };\n\n  Scheduler.now = function () {\n    return Date.now();\n  };\n\n  return Scheduler;\n}();\n/** PURE_IMPORTS_START tslib,_Scheduler PURE_IMPORTS_END */\n\n\nvar AsyncScheduler = /*@__PURE__*/function (_super) {\n  __extends(AsyncScheduler, _super);\n\n  function AsyncScheduler(SchedulerAction, now) {\n    if (now === void 0) {\n      now = Scheduler.now;\n    }\n\n    var _this = _super.call(this, SchedulerAction, function () {\n      if (AsyncScheduler.delegate && AsyncScheduler.delegate !== _this) {\n        return AsyncScheduler.delegate.now();\n      } else {\n        return now();\n      }\n    }) || this;\n\n    _this.actions = [];\n    _this.active = false;\n    _this.scheduled = undefined;\n    return _this;\n  }\n\n  AsyncScheduler.prototype.schedule = function (work, delay, state) {\n    if (delay === void 0) {\n      delay = 0;\n    }\n\n    if (AsyncScheduler.delegate && AsyncScheduler.delegate !== this) {\n      return AsyncScheduler.delegate.schedule(work, delay, state);\n    } else {\n      return _super.prototype.schedule.call(this, work, delay, state);\n    }\n  };\n\n  AsyncScheduler.prototype.flush = function (action) {\n    var actions = this.actions;\n\n    if (this.active) {\n      actions.push(action);\n      return;\n    }\n\n    var error;\n    this.active = true;\n\n    do {\n      if (error = action.execute(action.state, action.delay)) {\n        break;\n      }\n    } while (action = actions.shift());\n\n    this.active = false;\n\n    if (error) {\n      while (action = actions.shift()) {\n        action.unsubscribe();\n      }\n\n      throw error;\n    }\n  };\n\n  return AsyncScheduler;\n}(Scheduler);\n/** PURE_IMPORTS_START _AsyncAction,_AsyncScheduler PURE_IMPORTS_END */\n\n\nvar asyncScheduler = /*@__PURE__*/new AsyncScheduler(AsyncAction);\nvar async = asyncScheduler;\n/** PURE_IMPORTS_START  PURE_IMPORTS_END */\n\nfunction isDate(value) {\n  return value instanceof Date && !isNaN(+value);\n}\n/** PURE_IMPORTS_START _Observable PURE_IMPORTS_END */\n\n\nvar EMPTY = /*@__PURE__*/new Observable(function (subscriber) {\n  return subscriber.complete();\n});\n\nfunction empty$1(scheduler) {\n  return scheduler ? emptyScheduled(scheduler) : EMPTY;\n}\n\nfunction emptyScheduled(scheduler) {\n  return new Observable(function (subscriber) {\n    return scheduler.schedule(function () {\n      return subscriber.complete();\n    });\n  });\n}\n/** PURE_IMPORTS_START _Observable PURE_IMPORTS_END */\n\n\nfunction throwError(error, scheduler) {\n  if (!scheduler) {\n    return new Observable(function (subscriber) {\n      return subscriber.error(error);\n    });\n  } else {\n    return new Observable(function (subscriber) {\n      return scheduler.schedule(dispatch, 0, {\n        error: error,\n        subscriber: subscriber\n      });\n    });\n  }\n}\n\nfunction dispatch(_a) {\n  var error = _a.error,\n      subscriber = _a.subscriber;\n  subscriber.error(error);\n}\n/** PURE_IMPORTS_START  PURE_IMPORTS_END */\n\n\nvar ArgumentOutOfRangeErrorImpl = /*@__PURE__*/function () {\n  function ArgumentOutOfRangeErrorImpl() {\n    Error.call(this);\n    this.message = 'argument out of range';\n    this.name = 'ArgumentOutOfRangeError';\n    return this;\n  }\n\n  ArgumentOutOfRangeErrorImpl.prototype = /*@__PURE__*/Object.create(Error.prototype);\n  return ArgumentOutOfRangeErrorImpl;\n}();\n\nvar ArgumentOutOfRangeError = ArgumentOutOfRangeErrorImpl;\n/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */\n\nfunction filter(predicate, thisArg) {\n  return function filterOperatorFunction(source) {\n    return source.lift(new FilterOperator(predicate, thisArg));\n  };\n}\n\nvar FilterOperator = /*@__PURE__*/function () {\n  function FilterOperator(predicate, thisArg) {\n    this.predicate = predicate;\n    this.thisArg = thisArg;\n  }\n\n  FilterOperator.prototype.call = function (subscriber, source) {\n    return source.subscribe(new FilterSubscriber(subscriber, this.predicate, this.thisArg));\n  };\n\n  return FilterOperator;\n}();\n\nvar FilterSubscriber = /*@__PURE__*/function (_super) {\n  __extends(FilterSubscriber, _super);\n\n  function FilterSubscriber(destination, predicate, thisArg) {\n    var _this = _super.call(this, destination) || this;\n\n    _this.predicate = predicate;\n    _this.thisArg = thisArg;\n    _this.count = 0;\n    return _this;\n  }\n\n  FilterSubscriber.prototype._next = function (value) {\n    var result;\n\n    try {\n      result = this.predicate.call(this.thisArg, value, this.count++);\n    } catch (err) {\n      this.destination.error(err);\n      return;\n    }\n\n    if (result) {\n      this.destination.next(value);\n    }\n  };\n\n  return FilterSubscriber;\n}(Subscriber);\n/** PURE_IMPORTS_START tslib,_Subscriber,_util_ArgumentOutOfRangeError,_observable_empty PURE_IMPORTS_END */\n\n\nfunction take(count) {\n  return function (source) {\n    if (count === 0) {\n      return empty$1();\n    } else {\n      return source.lift(new TakeOperator(count));\n    }\n  };\n}\n\nvar TakeOperator = /*@__PURE__*/function () {\n  function TakeOperator(total) {\n    this.total = total;\n\n    if (this.total < 0) {\n      throw new ArgumentOutOfRangeError();\n    }\n  }\n\n  TakeOperator.prototype.call = function (subscriber, source) {\n    return source.subscribe(new TakeSubscriber(subscriber, this.total));\n  };\n\n  return TakeOperator;\n}();\n\nvar TakeSubscriber = /*@__PURE__*/function (_super) {\n  __extends(TakeSubscriber, _super);\n\n  function TakeSubscriber(destination, total) {\n    var _this = _super.call(this, destination) || this;\n\n    _this.total = total;\n    _this.count = 0;\n    return _this;\n  }\n\n  TakeSubscriber.prototype._next = function (value) {\n    var total = this.total;\n    var count = ++this.count;\n\n    if (count <= total) {\n      this.destination.next(value);\n\n      if (count === total) {\n        this.destination.complete();\n        this.unsubscribe();\n      }\n    }\n  };\n\n  return TakeSubscriber;\n}(Subscriber);\n/** PURE_IMPORTS_START tslib,_Subscriber,_Subscription PURE_IMPORTS_END */\n\n\nfunction finalize(callback) {\n  return function (source) {\n    return source.lift(new FinallyOperator(callback));\n  };\n}\n\nvar FinallyOperator = /*@__PURE__*/function () {\n  function FinallyOperator(callback) {\n    this.callback = callback;\n  }\n\n  FinallyOperator.prototype.call = function (subscriber, source) {\n    return source.subscribe(new FinallySubscriber(subscriber, this.callback));\n  };\n\n  return FinallyOperator;\n}();\n\nvar FinallySubscriber = /*@__PURE__*/function (_super) {\n  __extends(FinallySubscriber, _super);\n\n  function FinallySubscriber(destination, callback) {\n    var _this = _super.call(this, destination) || this;\n\n    _this.add(new Subscription(callback));\n\n    return _this;\n  }\n\n  return FinallySubscriber;\n}(Subscriber);\n/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */\n\n\nfunction takeWhile(predicate, inclusive) {\n  if (inclusive === void 0) {\n    inclusive = false;\n  }\n\n  return function (source) {\n    return source.lift(new TakeWhileOperator(predicate, inclusive));\n  };\n}\n\nvar TakeWhileOperator = /*@__PURE__*/function () {\n  function TakeWhileOperator(predicate, inclusive) {\n    this.predicate = predicate;\n    this.inclusive = inclusive;\n  }\n\n  TakeWhileOperator.prototype.call = function (subscriber, source) {\n    return source.subscribe(new TakeWhileSubscriber(subscriber, this.predicate, this.inclusive));\n  };\n\n  return TakeWhileOperator;\n}();\n\nvar TakeWhileSubscriber = /*@__PURE__*/function (_super) {\n  __extends(TakeWhileSubscriber, _super);\n\n  function TakeWhileSubscriber(destination, predicate, inclusive) {\n    var _this = _super.call(this, destination) || this;\n\n    _this.predicate = predicate;\n    _this.inclusive = inclusive;\n    _this.index = 0;\n    return _this;\n  }\n\n  TakeWhileSubscriber.prototype._next = function (value) {\n    var destination = this.destination;\n    var result;\n\n    try {\n      result = this.predicate(value, this.index++);\n    } catch (err) {\n      destination.error(err);\n      return;\n    }\n\n    this.nextOrComplete(value, result);\n  };\n\n  TakeWhileSubscriber.prototype.nextOrComplete = function (value, predicateResult) {\n    var destination = this.destination;\n\n    if (Boolean(predicateResult)) {\n      destination.next(value);\n    } else {\n      if (this.inclusive) {\n        destination.next(value);\n      }\n\n      destination.complete();\n    }\n  };\n\n  return TakeWhileSubscriber;\n}(Subscriber);\n/** PURE_IMPORTS_START  PURE_IMPORTS_END */\n\n\nvar TimeoutErrorImpl = /*@__PURE__*/function () {\n  function TimeoutErrorImpl() {\n    Error.call(this);\n    this.message = 'Timeout has occurred';\n    this.name = 'TimeoutError';\n    return this;\n  }\n\n  TimeoutErrorImpl.prototype = /*@__PURE__*/Object.create(Error.prototype);\n  return TimeoutErrorImpl;\n}();\n\nvar TimeoutError = TimeoutErrorImpl;\n/** PURE_IMPORTS_START tslib,_scheduler_async,_util_isDate,_innerSubscribe PURE_IMPORTS_END */\n\nfunction timeoutWith(due, withObservable, scheduler) {\n  if (scheduler === void 0) {\n    scheduler = async;\n  }\n\n  return function (source) {\n    var absoluteTimeout = isDate(due);\n    var waitFor = absoluteTimeout ? +due - scheduler.now() : Math.abs(due);\n    return source.lift(new TimeoutWithOperator(waitFor, absoluteTimeout, withObservable, scheduler));\n  };\n}\n\nvar TimeoutWithOperator = /*@__PURE__*/function () {\n  function TimeoutWithOperator(waitFor, absoluteTimeout, withObservable, scheduler) {\n    this.waitFor = waitFor;\n    this.absoluteTimeout = absoluteTimeout;\n    this.withObservable = withObservable;\n    this.scheduler = scheduler;\n  }\n\n  TimeoutWithOperator.prototype.call = function (subscriber, source) {\n    return source.subscribe(new TimeoutWithSubscriber(subscriber, this.absoluteTimeout, this.waitFor, this.withObservable, this.scheduler));\n  };\n\n  return TimeoutWithOperator;\n}();\n\nvar TimeoutWithSubscriber = /*@__PURE__*/function (_super) {\n  __extends(TimeoutWithSubscriber, _super);\n\n  function TimeoutWithSubscriber(destination, absoluteTimeout, waitFor, withObservable, scheduler) {\n    var _this = _super.call(this, destination) || this;\n\n    _this.absoluteTimeout = absoluteTimeout;\n    _this.waitFor = waitFor;\n    _this.withObservable = withObservable;\n    _this.scheduler = scheduler;\n\n    _this.scheduleTimeout();\n\n    return _this;\n  }\n\n  TimeoutWithSubscriber.dispatchTimeout = function (subscriber) {\n    var withObservable = subscriber.withObservable;\n\n    subscriber._unsubscribeAndRecycle();\n\n    subscriber.add(innerSubscribe(withObservable, new SimpleInnerSubscriber(subscriber)));\n  };\n\n  TimeoutWithSubscriber.prototype.scheduleTimeout = function () {\n    var action = this.action;\n\n    if (action) {\n      this.action = action.schedule(this, this.waitFor);\n    } else {\n      this.add(this.action = this.scheduler.schedule(TimeoutWithSubscriber.dispatchTimeout, this.waitFor, this));\n    }\n  };\n\n  TimeoutWithSubscriber.prototype._next = function (value) {\n    if (!this.absoluteTimeout) {\n      this.scheduleTimeout();\n    }\n\n    _super.prototype._next.call(this, value);\n  };\n\n  TimeoutWithSubscriber.prototype._unsubscribe = function () {\n    this.action = undefined;\n    this.scheduler = null;\n    this.withObservable = null;\n  };\n\n  return TimeoutWithSubscriber;\n}(SimpleOuterSubscriber);\n/** PURE_IMPORTS_START _scheduler_async,_util_TimeoutError,_timeoutWith,_observable_throwError PURE_IMPORTS_END */\n\n\nfunction timeout(due, scheduler) {\n  if (scheduler === void 0) {\n    scheduler = async;\n  }\n\n  return timeoutWith(due, throwError(new TimeoutError()), scheduler);\n}\n\nconst simulations$ = new rxjs__WEBPACK_IMPORTED_MODULE_2__.Subject();\n\nfunction simulate(system, network, transaction) {\n  if (this._destroyed) throw new Error('The WebSocket instance has been destroyed, re-initialize to continue making requests.');\n  const id = (0,nanoid__WEBPACK_IMPORTED_MODULE_3__.nanoid)(); // send payload to server\n\n  this._sendMessage({\n    categoryCode: 'simulate',\n    eventCode: 'txSimulation',\n    eventId: id,\n    transaction: transaction\n  });\n\n  return new Promise((resolve, reject) => {\n    simulations$.pipe(filter(({\n      eventId\n    }) => {\n      return eventId === id;\n    }), take(1)).subscribe({\n      next: ({\n        transaction\n      }) => resolve(transaction),\n      error: ({\n        error\n      }) => reject(error.message)\n    });\n  });\n}\n\nfunction multiSim(transactions) {\n  if (this._destroyed) throw new Error('The WebSocket instance has been destroyed, re-initialize to continue making requests.');\n  const id = (0,nanoid__WEBPACK_IMPORTED_MODULE_3__.nanoid)(); // send payload to server\n\n  this._sendMessage({\n    categoryCode: 'simulate',\n    eventCode: 'txSimulation',\n    eventId: id,\n    transaction: transactions\n  });\n\n  return new Promise((resolve, reject) => {\n    simulations$.pipe(filter(({\n      eventId\n    }) => {\n      return eventId === id;\n    }), take(1)).subscribe({\n      next: ({\n        transaction\n      }) => resolve(transaction),\n      error: ({\n        error\n      }) => reject(error.message)\n    });\n  });\n}\n\nfunction unsubscribe(addressOrHash) {\n  if (this._destroyed) throw new Error('The WebSocket instance has been destroyed, re-initialize to continue making requests.');\n  const address = isAddress(this._system, addressOrHash);\n  const txid = isTxid(this._system, addressOrHash); // check if it is an address or a hash\n\n  if (address) {\n    const normalizedAddress = this._system === 'ethereum' ? addressOrHash.toLowerCase() : addressOrHash; // remove address from accounts\n\n    this.watchedAccounts = this.watchedAccounts.filter(ac => ac.address !== normalizedAddress); // remove configuration from memory\n\n    this.configurations.delete(normalizedAddress); // logEvent to server\n\n    this._sendMessage({\n      categoryCode: 'accountAddress',\n      eventCode: 'unwatch',\n      account: {\n        address: normalizedAddress\n      }\n    });\n  } else if (txid) {\n    // remove transaction from transactions\n    this.watchedTransactions = this.watchedTransactions.filter(tx => tx.hash !== addressOrHash);\n    const transactionId = this._system === 'ethereum' ? {\n      hash: addressOrHash\n    } : {\n      txid: addressOrHash\n    };\n    const transaction = { ...transactionId,\n      id: addressOrHash,\n      status: 'unsubscribed'\n    }; // logEvent to server\n\n    this._sendMessage({\n      categoryCode: 'activeTransaction',\n      eventCode: 'unwatch',\n      transaction\n    });\n  } else {\n    throw new Error(`Error trying to unsubscribe ${addressOrHash}: not a valid address or transaction id/hash`);\n  }\n}\n\nfunction configuration(config) {\n  if (this._destroyed) {\n    throw new Error('The WebSocket instance has been destroyed, re-initialize to continue making requests.');\n  }\n\n  const casedScope = this._system === 'ethereum' ? config.scope.toLowerCase() : config.scope; // resolve previous configuration if exists\n\n  const previousConfiguration = this.configurations.get(casedScope);\n  previousConfiguration && previousConfiguration.subscription && previousConfiguration.subscription.next();\n  const subscription = new rxjs__WEBPACK_IMPORTED_MODULE_2__.Subject(); // create emitter for transaction\n\n  const emitter = config.watchAddress ? {\n    emitter: createEmitter()\n  } : {};\n  this.configurations.set(casedScope, { ...config,\n    ...emitter,\n    subscription\n  });\n\n  this._sendMessage({\n    categoryCode: 'configs',\n    eventCode: 'put',\n    config\n  });\n\n  return new Promise((resolve, reject) => {\n    subscription.pipe(take(1), timeout(5000)).subscribe({\n      next: () => resolve({ ...emitter,\n        details: {\n          config\n        }\n      }),\n      error: error => {\n        const message = error.message === 'Timeout has occurred' ? `Configuration with scope: ${config.scope} has been sent to the Blocknative server, but has not received a reply within 5 seconds.` : error.message;\n\n        if (this._onerror) {\n          this._onerror({\n            message\n          });\n\n          resolve(`Error: ${message}`);\n        } else {\n          reject(message);\n        }\n      }\n    });\n  });\n}\n\nfunction subscribe(subscription) {\n  const {\n    id,\n    chainId,\n    type\n  } = subscription;\n\n  if (!networkName('ethereum', parseInt(chainId, 16))) {\n    throw new Error(`chainId: ${chainId} is an unsupported network`);\n  }\n\n  if (!this.connections[chainId]) {\n    this.connections[chainId] = new this.Blocknative({\n      system: 'ethereum',\n      networkId: parseInt(chainId, 16),\n      dappId: this.apiKey,\n      ws: this.ws,\n      apiUrl: this.apiUrl,\n      transactionHandlers: [({\n        transaction\n      }) => {\n        this.onTransaction$.next(transaction);\n      }],\n      onerror: error => this.errors$.next(error)\n    });\n  }\n\n  const sdk = this.connections[chainId];\n\n  if (type === 'account') {\n    const {\n      filters = [],\n      abi\n    } = subscription;\n    sdk.configuration({\n      scope: id,\n      filters,\n      ...(abi ? {\n        abi\n      } : {}),\n      watchAddress: true\n    });\n    return this.transactions$.pipe(filter(({\n      watchedAddress\n    }) => watchedAddress === id), finalize(() => {\n      this.unsubscribe({\n        id,\n        chainId\n      });\n    }));\n  } else {\n    const {\n      emitter\n    } = sdk.transaction(id);\n    return (0,rxjs__WEBPACK_IMPORTED_MODULE_4__.fromEvent)( // eslint-disable-next-line\n    // @ts-ignore - string does not match specific eventcode string\n    emitter, 'all').pipe( // automatically complete stream on a finalized status\n    takeWhile(({\n      status\n    }) => status !== 'confirmed' && status !== 'failed' && status !== 'dropped', true), // cleanup subscription and SDK on completion\n    finalize(() => {\n      this.unsubscribe({\n        id,\n        chainId\n      });\n    }));\n  }\n}\n\nfunction unsubscribe$1(options) {\n  const {\n    id,\n    chainId,\n    timeout = 0\n  } = options;\n  const time$ = (0,rxjs__WEBPACK_IMPORTED_MODULE_5__.timer)(timeout);\n  const transactionEvent$ = this.transactions$.pipe(filter(({\n    hash,\n    watchedAddress\n  }) => hash === id || watchedAddress === id));\n  (0,rxjs__WEBPACK_IMPORTED_MODULE_6__.merge)(transactionEvent$, time$).pipe(take(1)) // take just first event\n  .subscribe(res => {\n    // if number, then timeout with no transaction events, so go ahead and unsub\n    if (typeof res === 'number') {\n      const sdkConnections = Object.entries(this.connections).filter(([chainId, sdk]) => sdk !== null);\n      sdkConnections.forEach(([connectionChainId, sdk]) => {\n        // if chainId is passed and it doesn't match, then no unsub (return early)\n        if (chainId && connectionChainId !== chainId) return;\n        sdk.unsubscribe(id); // if no remaining subscriptions, destroy connection and set to null\n\n        if (!sdk.watchedAccounts.length && !sdk.watchedTransactions.length && !sdk.configurations.size) {\n          sdk.destroy();\n          this.connections[connectionChainId] = null;\n        }\n      });\n    } else {\n      // otherwise a transaction event received, so call unsub again for another timeout\n      this.unsubscribe(options);\n    }\n  });\n} //**Experimental API that is not yet finalized and is in BETA*/\n\n\nclass MultiChain {\n  constructor(options, Blocknative) {\n    const {\n      ws\n    } = options;\n    const {\n      apiKey\n    } = options;\n    const {\n      apiUrl\n    } = options;\n    this.apiKey = apiKey;\n    this.apiUrl = apiUrl;\n    this.ws = ws;\n    this.connections = {};\n    this.onTransaction$ = new rxjs__WEBPACK_IMPORTED_MODULE_2__.Subject();\n    this.transactions$ = this.onTransaction$.asObservable();\n    this.errors$ = new rxjs__WEBPACK_IMPORTED_MODULE_2__.Subject();\n    this.Blocknative = Blocknative;\n    this.subscribe = subscribe.bind(this);\n    this.unsubscribe = unsubscribe$1.bind(this);\n  }\n\n}\n\nvar version = \"4.6.9\";\n\nfunction sendMessage(msg) {\n  if (this._queuedMessages.length > QUEUE_LIMIT) {\n    throw new Error(`Queue limit of ${QUEUE_LIMIT} messages has been reached.`);\n  }\n\n  this._queuedMessages.push(createEventLog.bind(this)(msg));\n\n  if (!this._processingQueue) {\n    this._processQueue();\n  }\n}\n\nasync function processQueue() {\n  this._processingQueue = true;\n\n  if (!this._connected) {\n    await waitForConnectionOpen.bind(this)();\n  }\n\n  while (this._queuedMessages.length > 0) {\n    // small wait to allow response from server to take affect\n    await wait(1);\n\n    if (this._waitToRetry !== null) {\n      // have been rate limited so wait\n      await this._waitToRetry;\n      this._waitToRetry = null;\n    }\n\n    const msg = this._queuedMessages.shift();\n\n    const delay = this._limitRules.duration / this._limitRules.points * 1000;\n    await wait(delay);\n\n    this._socket.send(msg);\n  }\n\n  this._processingQueue = false;\n  this._limitRules = DEFAULT_RATE_LIMIT_RULES;\n}\n\nfunction handleMessage(msg) {\n  const {\n    status,\n    reason,\n    event,\n    connectionId,\n    serverVersion,\n    retryMs,\n    limitRules,\n    blockedMsg,\n    dispatchTimestamp\n  } = JSON.parse(msg.data);\n\n  if (connectionId) {\n    if (isLocalStorageAvailable()) {\n      window.localStorage.setItem(this._storageKey, connectionId);\n    }\n\n    this._connectionId = connectionId;\n  } // handle any errors from the server\n\n\n  if (status === 'error') {\n    if (reason.includes('ratelimit') && !reason.match(/IP (PendingSimulation|Notification) ratelimit reached/)) {\n      this._waitToRetry = wait(retryMs);\n      this._limitRules = limitRules; // add blocked msg to the front of the queue\n\n      blockedMsg && this._queuedMessages.unshift(blockedMsg);\n      return;\n    }\n\n    if (reason.includes('upgrade your plan')) {\n      if (this._onerror) {\n        this._onerror({\n          message: reason\n        });\n\n        return;\n      } else {\n        throw new Error(reason);\n      }\n    }\n\n    if (reason.includes('not a valid API key')) {\n      if (this._onerror) {\n        this._onerror({\n          message: reason\n        });\n\n        return;\n      } else {\n        throw new Error(reason);\n      }\n    }\n\n    if (reason.includes('network not supported')) {\n      if (this._onerror) {\n        this._onerror({\n          message: reason\n        });\n\n        return;\n      } else {\n        throw new Error(reason);\n      }\n    }\n\n    if (reason.includes('maximum allowed amount')) {\n      if (this._onerror) {\n        this._onerror({\n          message: reason\n        });\n\n        return;\n      } else {\n        throw new Error(reason);\n      }\n    } // handle bitcoin txid error\n\n\n    if (reason.includes('invalid txid')) {\n      const reason = `${event.transaction.txid} is an invalid txid`;\n\n      if (this._onerror) {\n        this._onerror({\n          message: reason,\n          transaction: event.transaction.txid\n        });\n\n        return;\n      } else {\n        throw new Error(reason);\n      }\n    } // handle ethereum transaction hash error\n\n\n    if (reason.includes('invalid hash')) {\n      const reason = `${event.transaction.hash} is an invalid transaction hash`;\n\n      if (this._onerror) {\n        this._onerror({\n          message: reason,\n          transaction: event.transaction.hash\n        });\n\n        return;\n      } else {\n        throw new Error(reason);\n      }\n    } // handle general address error\n\n\n    if (reason.includes('invalid address')) {\n      const reason = `${event.account.address} is an invalid address`;\n\n      if (this._onerror) {\n        this._onerror({\n          message: reason,\n          account: event.account.address\n        });\n\n        return;\n      } else {\n        throw new Error(reason);\n      }\n    } // handle bitcoin specific address error\n\n\n    if (reason.includes('not a valid Bitcoin')) {\n      if (this._onerror) {\n        this._onerror({\n          message: reason,\n          account: event.account.address\n        });\n\n        return;\n      } else {\n        throw new Error(reason);\n      }\n    } // handle ethereum specific address error\n\n\n    if (reason.includes('not a valid Ethereum')) {\n      if (this._onerror) {\n        this._onerror({\n          message: reason,\n          account: event.account.address\n        });\n\n        return;\n      } else {\n        throw new Error(reason);\n      }\n    }\n\n    if (event && event.categoryCode === 'simulate') {\n      simulations$.error({\n        eventId: event.eventId,\n        error: {\n          message: reason\n        }\n      });\n      return;\n    } // handle config error\n\n\n    if (event && event.config) {\n      const configuration = this.configurations.get(event.config.scope);\n\n      if (configuration && configuration.subscription) {\n        configuration.subscription.error({\n          message: reason\n        });\n      }\n\n      return;\n    } // throw error that comes back from the server without formatting the message\n\n\n    if (this._onerror) {\n      this._onerror({\n        message: reason\n      });\n\n      return;\n    } else {\n      throw new Error(reason);\n    }\n  }\n\n  if (event && event.config) {\n    const casedScope = this._system === 'ethereum' ? event.config.scope.toLowerCase() : event.config.scope;\n    const configuration = this.configurations.get(casedScope);\n\n    if (configuration && configuration.subscription) {\n      configuration.subscription.next();\n    }\n  }\n\n  if (event && event.transaction) {\n    const {\n      eventId,\n      transaction,\n      eventCode,\n      contractCall,\n      timeStamp,\n      blockchain: {\n        system,\n        network\n      }\n    } = event; // flatten in to one object\n\n    const newState = this._system === 'ethereum' ? { ...transaction,\n      serverVersion,\n      eventCode,\n      timeStamp,\n      dispatchTimestamp,\n      system,\n      network,\n      contractCall\n    } : { ...transaction,\n      serverVersion,\n      eventCode,\n      timeStamp,\n      dispatchTimestamp,\n      system,\n      network\n    }; // ignore server echo and unsubscribe messages\n\n    if (serverEcho(eventCode) || transaction.status === 'unsubscribed') {\n      return;\n    } // replace originalHash to match webhook API\n\n\n    if (newState.originalHash) {\n      newState.replaceHash = newState.hash;\n      newState.hash = newState.originalHash;\n      delete newState.originalHash;\n    } // replace status to match webhook API\n\n\n    if (eventCode === 'txSpeedUp' && newState.status !== 'speedup') {\n      newState.status = 'speedup';\n    } // replace status to match webhook API\n\n\n    if (eventCode === 'txCancel' && newState.status !== 'cancel') {\n      newState.status = 'cancel';\n    } // handle change of hash in speedup and cancel events\n\n\n    if (eventCode === 'txSpeedUp' || eventCode === 'txCancel') {\n      this.watchedTransactions = this.watchedTransactions.map(tx => {\n        if (tx.hash === newState.replaceHash) {\n          // reassign hash parameter in transaction queue to new hash or txid\n          tx.hash = transaction.hash || transaction.txid;\n        }\n\n        return tx;\n      });\n    }\n\n    if (event && event.categoryCode === 'simulate') {\n      newState.contractCall = event.transaction.contractCall;\n      delete newState.dispatchTimestamp;\n      simulations$.next({\n        eventId,\n        transaction: newState\n      });\n      return;\n    }\n\n    const watchedAddress = transaction.watchedAddress && this._system === 'ethereum' ? transaction.watchedAddress.toLowerCase() : transaction.watchedAddress;\n\n    if (watchedAddress) {\n      const accountObj = this.watchedAccounts.find(ac => ac.address === watchedAddress);\n      const accountEmitterResult = accountObj ? last(accountObj.emitters.map(emitter => emitter.emit(newState))) : false;\n      const configuration = this.configurations.get(watchedAddress);\n      const emitterResult = configuration && configuration.emitter ? configuration.emitter.emit(newState) || accountEmitterResult : accountEmitterResult;\n\n      this._transactionHandlers.forEach(handler => handler({\n        transaction: newState,\n        emitterResult\n      }));\n    } else {\n      const transactionObj = this.watchedTransactions.find(tx => tx.hash === newState.hash || newState.txid);\n      const emitterResult = transactionObj && transactionObj.emitter.emit(newState);\n\n      this._transactionHandlers.forEach(handler => handler({\n        transaction: newState,\n        emitterResult\n      })); // replace the emitter hash to the replace hash on replacement txs\n\n\n      if (newState.status === 'speedup' || newState.status === 'cancel') {\n        this.watchedTransactions = this.watchedTransactions.map(tx => {\n          if (tx.hash === newState.hash || newState.txid) {\n            return { ...tx,\n              hash: newState.replaceHash\n            };\n          }\n\n          return tx;\n        });\n      }\n    }\n  }\n}\n\nfunction createEventLog(msg) {\n  return JSON.stringify({\n    timeStamp: new Date().toISOString(),\n    dappId: this._dappId,\n    version,\n    appName: this._appName,\n    appVersion: this._appVersion,\n    blockchain: {\n      system: this._system,\n      network: networkName(this._system, this._networkId) || 'local'\n    },\n    ...msg\n  }, msg.categoryCode === 'configs' ? jsonPreserveUndefined : undefined);\n}\n\nfunction waitForConnectionOpen() {\n  return new Promise(resolve => {\n    const interval = setInterval(() => {\n      if (this._connected) {\n        setTimeout(resolve, 100);\n        clearInterval(interval);\n      }\n    });\n  });\n}\n\nconst DEFAULT_APP_NAME = 'unknown';\nconst DEFAULT_APP_VERSION = 'unknown';\nconst DEFAULT_SYSTEM = 'ethereum';\n\nclass SDK {\n  constructor(options) {\n    validateOptions(options);\n    const {\n      system = DEFAULT_SYSTEM,\n      name = DEFAULT_APP_NAME,\n      appVersion = DEFAULT_APP_VERSION,\n      networkId,\n      transactionHandlers = [],\n      ws,\n      onopen,\n      ondown,\n      onreopen,\n      onerror,\n      onclose\n    } = options;\n    const {\n      apiUrl\n    } = options;\n    const {\n      dappId\n    } = options; // override default timeout to allow for slow connections\n\n    const timeout = {\n      connectTimeout: 10000\n    };\n    const socket = new sturdy_websocket__WEBPACK_IMPORTED_MODULE_0__[\"default\"](apiUrl || 'wss://api.blocknative.com/v0', ws ? {\n      wsConstructor: ws,\n      ...timeout\n    } : { ...timeout\n    });\n    socket.onopen = onOpen.bind(this, onopen);\n    socket.ondown = onDown.bind(this, ondown);\n    socket.onreopen = onReopen.bind(this, onreopen);\n    socket.onmessage = handleMessage.bind(this);\n\n    socket.onerror = error => onerror && onerror({\n      message: 'There was a WebSocket error',\n      error\n    });\n\n    socket.onclose = () => {\n      this._pingTimeout && clearInterval(this._pingTimeout);\n      onclose && onclose();\n    };\n\n    const storageKey = crypto_es__WEBPACK_IMPORTED_MODULE_1__[\"default\"].SHA1(`${dappId} - ${name}`).toString();\n    const storedConnectionId = isLocalStorageAvailable() && window.localStorage.getItem(storageKey);\n    this._storageKey = storageKey;\n    this._connectionId = storedConnectionId || undefined;\n    this._dappId = dappId;\n    this._system = system;\n    this._networkId = networkId;\n    this._appName = name;\n    this._appVersion = appVersion;\n    this._transactionHandlers = transactionHandlers;\n    this._socket = socket;\n    this._connected = false;\n    this._sendMessage = sendMessage.bind(this);\n    this._pingTimeout = undefined;\n    this._destroyed = false;\n    this._onerror = onerror;\n    this._queuedMessages = [];\n    this._limitRules = DEFAULT_RATE_LIMIT_RULES;\n    this._waitToRetry = null;\n    this._processingQueue = false;\n    this._processQueue = processQueue.bind(this);\n\n    if (this._socket.ws.on) {\n      this._heartbeat = () => {\n        this._pingTimeout && clearTimeout(this._pingTimeout);\n        this._pingTimeout = setTimeout(() => {\n          // terminate connection if we haven't heard the server ping after server timeout plus conservative latency delay\n          // Sturdy Websocket will handle the new connection logic\n          this._socket.ws.terminate();\n        }, 30000 + 1000);\n      };\n\n      this._socket.ws.on('ping', () => {\n        this._heartbeat && this._heartbeat();\n      });\n    } // public API\n\n\n    this.watchedTransactions = [];\n    this.watchedAccounts = [];\n    this.configurations = new Map();\n    this.transaction = transaction.bind(this);\n    this.account = account.bind(this);\n    this.event = event.bind(this);\n    this.simulate = simulate.bind(this);\n    this.multiSim = multiSim.bind(this);\n    this.unsubscribe = unsubscribe.bind(this);\n    this.configuration = configuration.bind(this);\n\n    this.destroy = () => {\n      this._socket.close();\n\n      this._destroyed = true; // call onclose manually here as SturdyWebSocket doesn't currently work as expected\n      // https://github.com/dphilipson/sturdy-websocket/issues/5\n\n      this._socket.onclose();\n    };\n  }\n\n  static multichain(options) {\n    return new MultiChain(options, this);\n  }\n\n}\n\nfunction onOpen(handler) {\n  this._connected = true;\n  const msg = {\n    categoryCode: 'initialize',\n    eventCode: 'checkDappId',\n    connectionId: this._connectionId\n  }; // send this message directly rather than put in queue\n\n  this._socket.send(createEventLog.bind(this)(msg));\n\n  this._heartbeat && this._heartbeat();\n  handler && handler();\n}\n\nfunction onDown(handler, closeEvent) {\n  this._connected = false;\n\n  if (handler) {\n    handler(closeEvent);\n  }\n\n  this._pingTimeout && clearTimeout(this._pingTimeout);\n}\n\nasync function onReopen(handler) {\n  this._connected = true;\n  const msg = {\n    categoryCode: 'initialize',\n    eventCode: 'checkDappId',\n    connectionId: this._connectionId\n  };\n\n  this._socket.send(createEventLog.bind(this)(msg)); // re-register all configurations on re-connection\n\n\n  const configurations = Array.from(this.configurations.values()); // register global config first and wait for it to complete\n\n  const globalConfiguration = this.configurations.get('global');\n\n  if (globalConfiguration) {\n    try {\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      const {\n        emitter,\n        subscription,\n        ...config\n      } = globalConfiguration;\n      await this.configuration(config);\n    } catch (error) {\n      console.warn('Error re-sending global configuration upon reconnection:', error);\n    }\n  }\n\n  const addressConfigurations = configurations.filter(({\n    scope\n  }) => scope !== 'global');\n  addressConfigurations.forEach(enhancedConfig => {\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    const {\n      emitter,\n      subscription,\n      ...config\n    } = enhancedConfig;\n\n    this._sendMessage({\n      categoryCode: 'configs',\n      eventCode: 'put',\n      config\n    });\n  }); // re-register all accounts to be watched by server upon\n  // re-connection as they don't get transferred over automatically\n  // to the new connection like tx hashes do\n\n  this.watchedAccounts.forEach(account => {\n    this._sendMessage({\n      eventCode: 'accountAddress',\n      categoryCode: 'watch',\n      account: {\n        address: account.address\n      }\n    });\n  });\n\n  if (handler) {\n    handler();\n  }\n\n  if (this._socket.ws && this._socket.ws.on) {\n    // need to re-register ping event since new connection\n    this._socket.ws.on('ping', () => {\n      this._heartbeat && this._heartbeat();\n    });\n\n    this._heartbeat();\n  }\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SDK);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYm5jLXNkay9kaXN0L2VzbS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUErQztBQUNkO0FBQ0Q7QUFDd0I7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBLHdCQUF3QixLQUFLO0FBQzdCOztBQUVBO0FBQ0Esd0JBQXdCLEtBQUsscUJBQXFCLEtBQUssbUJBQW1CLGNBQWMsY0FBYyxNQUFNO0FBQzVHOztBQUVBO0FBQ0Esd0JBQXdCLE1BQU0sb0JBQW9CLEtBQUs7QUFDdkQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSx1REFBdUQsV0FBVztBQUNsRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSx1QkFBdUIsWUFBWSwrQkFBK0IsYUFBYSxtREFBbUQsdUJBQXVCO0FBQ3pKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2QkFBNkIsV0FBVztBQUN4QyxRQUFROzs7QUFHUjtBQUNBO0FBQ0EsUUFBUTs7O0FBR1I7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGlJQUFpSTs7QUFFakksZ0NBQWdDOztBQUVoQyxtQ0FBbUM7O0FBRW5DLDhCQUE4Qjs7QUFFOUI7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7OztBQUdKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlJQUFpSTs7QUFFakksMkVBQTJFOztBQUUzRSxtQ0FBbUM7O0FBRW5DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7OztBQUdKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sMEJBQTBCLGlDQUFpQztBQUMzRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEscUJBQXFCLHVCQUF1QjtBQUM1QztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLHdDQUF3QywrQkFBK0I7QUFDdkU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FB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QUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSw4QkFBOEI7QUFDOUI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFEQUFxRDs7O0FBR3JELG1FQUFtRTs7QUFFbkU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHLEdBQUc7QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUEsaUVBQWUsR0FBRyxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZ2l0aHVic3RyZWFtaW5nLy4vbm9kZV9tb2R1bGVzL2JuYy1zZGsvZGlzdC9lc20vaW5kZXguanM/NGNmNiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgU3R1cmR5V2ViU29ja2V0IGZyb20gJ3N0dXJkeS13ZWJzb2NrZXQnO1xuaW1wb3J0IENyeXB0b0VzIGZyb20gJ2NyeXB0by1lcyc7XG5pbXBvcnQgeyBuYW5vaWQgfSBmcm9tICduYW5vaWQnO1xuaW1wb3J0IHsgU3ViamVjdCwgZnJvbUV2ZW50LCB0aW1lciwgbWVyZ2UgfSBmcm9tICdyeGpzJztcbmNvbnN0IG5ldHdvcmtzID0ge1xuICBldGhlcmV1bToge1xuICAgICcxJzogJ21haW4nLFxuICAgICcxMTE1NTExMSc6ICdzZXBvbGlhJyxcbiAgICAnMTAwJzogJ3hkYWknLFxuICAgICcxMzcnOiAnbWF0aWMtbWFpbicsXG4gICAgJzgwMDAyJzogJ21hdGljLWFtb3knXG4gIH1cbn07XG5jb25zdCBERVBSRUNBVEVEX05FVFdPUktfSURTID0gWzIsIDMsIDQsIDQyLCA1NiwgMjUwXTtcbmNvbnN0IERFRkFVTFRfUkFURV9MSU1JVF9SVUxFUyA9IHtcbiAgcG9pbnRzOiAxNTAsXG4gIGR1cmF0aW9uOiAxXG59O1xuY29uc3QgUVVFVUVfTElNSVQgPSAxMDAwMDtcblxuZnVuY3Rpb24gdmFsaWRhdGVUeXBlKG9wdGlvbnMpIHtcbiAgY29uc3Qge1xuICAgIG5hbWUsXG4gICAgdmFsdWUsXG4gICAgdHlwZSxcbiAgICBvcHRpb25hbCxcbiAgICBjdXN0b21WYWxpZGF0aW9uXG4gIH0gPSBvcHRpb25zO1xuXG4gIGlmICghb3B0aW9uYWwgJiYgdHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJykge1xuICAgIHRocm93IG5ldyBFcnJvcihgXCIke25hbWV9XCIgaXMgcmVxdWlyZWRgKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUgIT09ICd1bmRlZmluZWQnICYmICh0eXBlID09PSAnYXJyYXknID8gQXJyYXkuaXNBcnJheSh0eXBlKSA6IHR5cGVvZiB2YWx1ZSAhPT0gdHlwZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFwiJHtuYW1lfVwiIG11c3QgYmUgb2YgdHlwZTogJHt0eXBlfSwgcmVjZWl2ZWQgdHlwZTogJHt0eXBlb2YgdmFsdWV9IGZyb20gdmFsdWU6ICR7dmFsdWV9YCk7XG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlICE9PSAndW5kZWZpbmVkJyAmJiBjdXN0b21WYWxpZGF0aW9uICYmICFjdXN0b21WYWxpZGF0aW9uKHZhbHVlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgXCIke3ZhbHVlfVwiIGlzIG5vdCBhIHZhbGlkIFwiJHtuYW1lfVwiYCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVPcHRpb25zKG9wdGlvbnMpIHtcbiAgdmFsaWRhdGVUeXBlKHtcbiAgICBuYW1lOiAnc2RrIG9wdGlvbnMnLFxuICAgIHZhbHVlOiBvcHRpb25zLFxuICAgIHR5cGU6ICdvYmplY3QnXG4gIH0pO1xuICBjb25zdCB7XG4gICAgZGFwcElkLFxuICAgIHN5c3RlbSxcbiAgICBuYW1lLFxuICAgIGFwcFZlcnNpb24sXG4gICAgbmV0d29ya0lkLFxuICAgIHRyYW5zYWN0aW9uSGFuZGxlcnMsXG4gICAgYXBpVXJsLFxuICAgIHdzLFxuICAgIG9ub3BlbixcbiAgICBvbmRvd24sXG4gICAgb25yZW9wZW4sXG4gICAgb25lcnJvcixcbiAgICBvbmNsb3NlLFxuICAgIC4uLm90aGVyUGFyYW1zXG4gIH0gPSBvcHRpb25zO1xuICBpbnZhbGlkUGFyYW1zKG90aGVyUGFyYW1zLCBbJ2RhcHBJZCcsICdzeXN0ZW0nLCAnbmFtZScsICdhcHBWZXJzaW9uJywgJ25ldHdvcmtJZCcsICd0cmFuc2FjdGlvbkhhbmRsZXJzJywgJ2FwaVVybCcsICd3cycsICdvbm9wZW4nLCAnb25kb3duJywgJ29ucmVvcGVuJywgJ29uZXJyb3InLCAnb25jbG9zZSddLCAnSW5pdGlhbGl6YXRpb24gT3B0aW9ucycpO1xuICB2YWxpZGF0ZVR5cGUoe1xuICAgIG5hbWU6ICdkYXBwSWQnLFxuICAgIHZhbHVlOiBkYXBwSWQsXG4gICAgdHlwZTogJ3N0cmluZycsXG4gICAgb3B0aW9uYWw6IHRydWVcbiAgfSk7XG4gIHZhbGlkYXRlVHlwZSh7XG4gICAgbmFtZTogJ3N5c3RlbScsXG4gICAgdmFsdWU6IHN5c3RlbSxcbiAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICBjdXN0b21WYWxpZGF0aW9uOiB2YWxpZFN5c3RlbVxuICB9KTtcbiAgdmFsaWRhdGVUeXBlKHtcbiAgICBuYW1lOiAnbmFtZScsXG4gICAgdmFsdWU6IG5hbWUsXG4gICAgdHlwZTogJ3N0cmluZycsXG4gICAgb3B0aW9uYWw6IHRydWVcbiAgfSk7XG4gIHZhbGlkYXRlVHlwZSh7XG4gICAgbmFtZTogJ2FwcFZlcnNpb24nLFxuICAgIHZhbHVlOiBhcHBWZXJzaW9uLFxuICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgIG9wdGlvbmFsOiB0cnVlXG4gIH0pO1xuICB2YWxpZGF0ZVR5cGUoe1xuICAgIG5hbWU6ICduZXR3b3JrSWQnLFxuICAgIHZhbHVlOiBuZXR3b3JrSWQsXG4gICAgdHlwZTogJ251bWJlcidcbiAgfSk7XG5cbiAgaWYgKERFUFJFQ0FURURfTkVUV09SS19JRFMuaW5jbHVkZXMobmV0d29ya0lkKSkge1xuICAgIGNvbnNvbGUuZXJyb3IoYEJsb2NrbmF0aXZlIFNESzogTmV0d29yayB3aXRoIElEOiAke25ldHdvcmtJZH0gaGFzIGJlZW4gZGVwcmVjYXRlZCBhbmQgeW91IHdpbGwgbm8gbG9uZ2VyIHJlY2VpdmUgdHJhbnNhY3Rpb24gZXZlbnRzIG9uIHRoaXMgbmV0d29yay5gKTtcbiAgfVxuXG4gIHZhbGlkYXRlVHlwZSh7XG4gICAgbmFtZTogJ3RyYW5zYWN0aW9uSGFuZGxlcicsXG4gICAgdmFsdWU6IHRyYW5zYWN0aW9uSGFuZGxlcnMsXG4gICAgdHlwZTogJ2FycmF5JyxcbiAgICBvcHRpb25hbDogdHJ1ZVxuICB9KTtcblxuICBpZiAodHJhbnNhY3Rpb25IYW5kbGVycykge1xuICAgIHRyYW5zYWN0aW9uSGFuZGxlcnMuZm9yRWFjaChoYW5kbGVyID0+IHZhbGlkYXRlVHlwZSh7XG4gICAgICBuYW1lOiAndHJhbnNhY3Rpb25IYW5kbGVyJyxcbiAgICAgIHZhbHVlOiBoYW5kbGVyLFxuICAgICAgdHlwZTogJ2Z1bmN0aW9uJ1xuICAgIH0pKTtcbiAgfVxuXG4gIHZhbGlkYXRlVHlwZSh7XG4gICAgbmFtZTogJ2FwaVVybCcsXG4gICAgdmFsdWU6IGFwaVVybCxcbiAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICBvcHRpb25hbDogdHJ1ZVxuICB9KTtcbiAgdmFsaWRhdGVUeXBlKHtcbiAgICBuYW1lOiAnd3MnLFxuICAgIHZhbHVlOiB3cyxcbiAgICB0eXBlOiAnZnVuY3Rpb24nLFxuICAgIG9wdGlvbmFsOiB0cnVlXG4gIH0pO1xuICB2YWxpZGF0ZVR5cGUoe1xuICAgIG5hbWU6ICdvbm9wZW4nLFxuICAgIHZhbHVlOiBvbm9wZW4sXG4gICAgdHlwZTogJ2Z1bmN0aW9uJyxcbiAgICBvcHRpb25hbDogdHJ1ZVxuICB9KTtcbiAgdmFsaWRhdGVUeXBlKHtcbiAgICBuYW1lOiAnb25kb3duJyxcbiAgICB2YWx1ZTogb25kb3duLFxuICAgIHR5cGU6ICdmdW5jdGlvbicsXG4gICAgb3B0aW9uYWw6IHRydWVcbiAgfSk7XG4gIHZhbGlkYXRlVHlwZSh7XG4gICAgbmFtZTogJ29ucmVvcGVuJyxcbiAgICB2YWx1ZTogb25yZW9wZW4sXG4gICAgdHlwZTogJ2Z1bmN0aW9uJyxcbiAgICBvcHRpb25hbDogdHJ1ZVxuICB9KTtcbiAgdmFsaWRhdGVUeXBlKHtcbiAgICBuYW1lOiAnb25lcnJvcicsXG4gICAgdmFsdWU6IG9uZXJyb3IsXG4gICAgdHlwZTogJ2Z1bmN0aW9uJyxcbiAgICBvcHRpb25hbDogdHJ1ZVxuICB9KTtcbiAgdmFsaWRhdGVUeXBlKHtcbiAgICBuYW1lOiAnb25jbG9zZScsXG4gICAgdmFsdWU6IG9uY2xvc2UsXG4gICAgdHlwZTogJ2Z1bmN0aW9uJyxcbiAgICBvcHRpb25hbDogdHJ1ZVxuICB9KTtcbn1cblxuZnVuY3Rpb24gdmFsaWRTeXN0ZW0oc3lzdGVtKSB7XG4gIHJldHVybiAhIW5ldHdvcmtzW3N5c3RlbV07XG59XG5cbmZ1bmN0aW9uIGludmFsaWRQYXJhbXMocGFyYW1zLCB2YWxpZFBhcmFtcywgZnVuY3Rpb25OYW1lKSB7XG4gIGNvbnN0IGludmFsaWQgPSBPYmplY3Qua2V5cyhwYXJhbXMpO1xuXG4gIGlmIChpbnZhbGlkLmxlbmd0aCA+IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYCR7aW52YWxpZFswXX0gaXMgbm90IGEgdmFsaWQgcGFyYW1ldGVyIGZvciAke2Z1bmN0aW9uTmFtZX0sIG11c3QgYmUgb25lIG9mIHRoZSBmb2xsb3dpbmcgdmFsaWQgcGFyYW1ldGVyczogJHt2YWxpZFBhcmFtcy5qb2luKCcsICcpfWApO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUVtaXR0ZXIoKSB7XG4gIHJldHVybiB7XG4gICAgbGlzdGVuZXJzOiB7fSxcbiAgICBvbjogZnVuY3Rpb24gKGV2ZW50Q29kZSwgbGlzdGVuZXIpIHtcbiAgICAgIC8vIGNoZWNrIGlmIHZhbGlkIGV2ZW50Q29kZVxuICAgICAgc3dpdGNoIChldmVudENvZGUpIHtcbiAgICAgICAgY2FzZSAndHhTZW50JzpcbiAgICAgICAgY2FzZSAndHhQb29sJzpcbiAgICAgICAgY2FzZSAndHhDb25maXJtZWQnOlxuICAgICAgICBjYXNlICd0eFNwZWVkVXAnOlxuICAgICAgICBjYXNlICd0eENhbmNlbCc6XG4gICAgICAgIGNhc2UgJ3R4RmFpbGVkJzpcbiAgICAgICAgY2FzZSAndHhEcm9wcGVkJzpcbiAgICAgICAgY2FzZSAndHhSZXF1ZXN0JzpcbiAgICAgICAgY2FzZSAnbnNmRmFpbCc6XG4gICAgICAgIGNhc2UgJ3R4UmVwZWF0JzpcbiAgICAgICAgY2FzZSAndHhBd2FpdGluZ0FwcHJvdmFsJzpcbiAgICAgICAgY2FzZSAndHhDb25maXJtUmVtaW5kZXInOlxuICAgICAgICBjYXNlICd0eFNlbmRGYWlsJzpcbiAgICAgICAgY2FzZSAndHhFcnJvcic6XG4gICAgICAgIGNhc2UgJ3R4VW5kZXJQcmljZWQnOlxuICAgICAgICBjYXNlICd0eFBvb2xTaW11bGF0aW9uJzpcbiAgICAgICAgY2FzZSAnYWxsJzpcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtldmVudENvZGV9IGlzIG5vdCBhIHZhbGlkIGV2ZW50IGNvZGUsIGZvciBhIGxpc3Qgb2YgdmFsaWQgZXZlbnQgY29kZXMgc2VlOiBodHRwczovL2RvY3MuYmxvY2tuYXRpdmUuY29tL25vdGlmeS1zZGsjZXZlbnQtY29kZXNgKTtcbiAgICAgIH0gLy8gY2hlY2sgdGhhdCBsaXN0ZW5lciBpcyBhIGZ1bmN0aW9uXG5cblxuICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgICAgfSAvLyBhZGQgbGlzdGVuZXIgZm9yIHRoZSBldmVudENvZGVcblxuXG4gICAgICB0aGlzLmxpc3RlbmVyc1tldmVudENvZGVdID0gbGlzdGVuZXI7XG4gICAgfSxcbiAgICBvZmY6IGZ1bmN0aW9uIChldmVudENvZGUpIHtcbiAgICAgIGRlbGV0ZSB0aGlzLmxpc3RlbmVyc1tldmVudENvZGVdO1xuICAgIH0sXG4gICAgZW1pdDogZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgICBpZiAodGhpcy5saXN0ZW5lcnNbc3RhdGUuZXZlbnRDb2RlXSkge1xuICAgICAgICByZXR1cm4gdGhpcy5saXN0ZW5lcnNbc3RhdGUuZXZlbnRDb2RlXShzdGF0ZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmxpc3RlbmVycy5hbGwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGlzdGVuZXJzLmFsbChzdGF0ZSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBuZXR3b3JrTmFtZShibG9ja2NoYWluLCBpZCkge1xuICByZXR1cm4gbmV0d29ya3NbYmxvY2tjaGFpbl1baWRdO1xufVxuXG5mdW5jdGlvbiBzZXJ2ZXJFY2hvKGV2ZW50Q29kZSkge1xuICBzd2l0Y2ggKGV2ZW50Q29kZSkge1xuICAgIGNhc2UgJ3R4UmVxdWVzdCc6XG4gICAgY2FzZSAnbnNmRmFpbCc6XG4gICAgY2FzZSAndHhSZXBlYXQnOlxuICAgIGNhc2UgJ3R4QXdhaXRpbmdBcHByb3ZhbCc6XG4gICAgY2FzZSAndHhDb25maXJtUmVtaW5kZXInOlxuICAgIGNhc2UgJ3R4U2VuZEZhaWwnOlxuICAgIGNhc2UgJ3R4RXJyb3InOlxuICAgIGNhc2UgJ3R4VW5kZXJQcmljZWQnOlxuICAgIGNhc2UgJ3R4U2VudCc6XG4gICAgICByZXR1cm4gdHJ1ZTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gbGFzdChhcnIpIHtcbiAgcmV0dXJuIGFyci5yZXZlcnNlKClbMF07XG59IC8vIGlzQWRkcmVzcyBhbmQgaXNUeGlkIGFyZSBub3QgbWVhbnQgdG8gcGVyZm9ybSByZWFsIHZhbGlkYXRpb24sXG4vLyBqdXN0IG5lZWRzIHRvIHdvcmsgb3V0IGlmIGl0IGlzIGFuIGFkZHJlc3Mgb3IgYSB0cmFuc2FjdGlvbiBpZFxuLy8gdGhlIHNlcnZlciB3aWxsIGRvIG1vcmUgdGhvcm91Z2ggdmFsaWRhdGlvblxuXG5cbmZ1bmN0aW9uIGlzQWRkcmVzcyhibG9ja2NoYWluLCBhZGRyZXNzT3JIYXNoKSB7XG4gIHN3aXRjaCAoYmxvY2tjaGFpbikge1xuICAgIGNhc2UgJ2V0aGVyZXVtJzpcbiAgICAgIHJldHVybiBhZGRyZXNzT3JIYXNoLmxlbmd0aCA9PT0gNDI7XG5cbiAgICBjYXNlICdiaXRjb2luJzpcbiAgICAgIHJldHVybiBhZGRyZXNzT3JIYXNoLmxlbmd0aCAhPT0gNjQ7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzVHhpZChibG9ja2NoYWluLCBhZGRyZXNzT3JIYXNoKSB7XG4gIHN3aXRjaCAoYmxvY2tjaGFpbikge1xuICAgIGNhc2UgJ2V0aGVyZXVtJzpcbiAgICAgIHJldHVybiBhZGRyZXNzT3JIYXNoLmxlbmd0aCA9PT0gNjY7XG5cbiAgICBjYXNlICdiaXRjb2luJzpcbiAgICAgIHJldHVybiBhZGRyZXNzT3JIYXNoLmxlbmd0aCA9PT0gNjQ7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHdhaXQodGltZSkge1xuICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgc2V0VGltZW91dChyZXNvbHZlLCB0aW1lKTtcbiAgfSk7XG59XG5cbmNvbnN0IGpzb25QcmVzZXJ2ZVVuZGVmaW5lZCA9IChrLCB2KSA9PiB2ID09PSB1bmRlZmluZWQgPyAndW5kZWZpbmVkJyA6IHY7XG4vKipcclxuICogVGVzdHMgaWYgTG9jYWxTdG9yYWdlIG1heSBiZSB1c2VkLiBBY2NvdW50cyBmb3IgZW52aXJvbm1lbnRzIHdoZXJlXHJcbiAqIExvY2FsU3RvcmFnZSBpcyBub3Qgc3VwcG9ydGVkLCBhcyB3ZWxsIGFzIHRob3NlIHdoZXJlIGl0IGlzIGJsb2NrZWQuXHJcbiAqXHJcbiAqIEByZXR1cm5zIGB0cnVlYCBpZiBMb2NhbFN0b3JhZ2UgaXMgc3VwcG9ydGVkIGFuZCBhY2Nlc3NpYmxlLCBgZmFsc2VgIG90aGVyd2lzZS5cclxuICovXG5cblxuZnVuY3Rpb24gaXNMb2NhbFN0b3JhZ2VBdmFpbGFibGUoKSB7XG4gIGNvbnN0IGlzU3VwcG9ydGVkID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgJ2xvY2FsU3RvcmFnZScgaW4gd2luZG93O1xuXG4gIGlmIChpc1N1cHBvcnRlZCkge1xuICAgIGNvbnN0IHRlc3RLZXkgPSAnX190ZXN0TG9jYWxTdG9yYWdlJztcblxuICAgIHRyeSB7XG4gICAgICB3aW5kb3cubG9jYWxTdG9yYWdlLnNldEl0ZW0odGVzdEtleSwgJzEnKTtcbiAgICAgIHdpbmRvdy5sb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSh0ZXN0S2V5KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gdHJhbnNhY3Rpb24oaGFzaCwgaWQpIHtcbiAgaWYgKHRoaXMuX2Rlc3Ryb3llZCkgdGhyb3cgbmV3IEVycm9yKCdUaGUgV2ViU29ja2V0IGluc3RhbmNlIGhhcyBiZWVuIGRlc3Ryb3llZCwgcmUtaW5pdGlhbGl6ZSB0byBjb250aW51ZSBtYWtpbmcgcmVxdWVzdHMuJyk7IC8vIGNyZWF0ZSBzdGFydFRpbWUgZm9yIHRyYW5zYWN0aW9uXG5cbiAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTsgLy8gY3JlYXRlIGVtaXR0ZXIgZm9yIHRyYW5zYWN0aW9uXG5cbiAgY29uc3QgZW1pdHRlciA9IGNyZWF0ZUVtaXR0ZXIoKTsgLy8gY3JlYXRlIGV2ZW50Q29kZSBmb3IgdHJhbnNhY3Rpb25cblxuICBjb25zdCBldmVudENvZGUgPSAndHhTZW50JzsgLy8gcHV0IGluIHF1ZXVlXG5cbiAgdGhpcy53YXRjaGVkVHJhbnNhY3Rpb25zLnB1c2goe1xuICAgIGhhc2gsXG4gICAgZW1pdHRlclxuICB9KTtcbiAgY29uc3QgdHJhbnNhY3Rpb25JZCA9IHRoaXMuX3N5c3RlbSA9PT0gJ2V0aGVyZXVtJyA/IHtcbiAgICBoYXNoXG4gIH0gOiB7XG4gICAgdHhpZDogaGFzaFxuICB9O1xuICBjb25zdCB0cmFuc2FjdGlvbiA9IHsgLi4udHJhbnNhY3Rpb25JZCxcbiAgICBpZDogaWQgfHwgaGFzaCxcbiAgICBzdGFydFRpbWUsXG4gICAgc3RhdHVzOiAnc2VudCdcbiAgfTtcbiAgY29uc3QgbmV3U3RhdGUgPSB7IC4uLnRyYW5zYWN0aW9uLFxuICAgIGV2ZW50Q29kZVxuICB9OyAvLyBsb2dFdmVudCB0byBzZXJ2ZXJcblxuICB0aGlzLl9zZW5kTWVzc2FnZSh7XG4gICAgZXZlbnRDb2RlLFxuICAgIGNhdGVnb3J5Q29kZTogJ2FjdGl2ZVRyYW5zYWN0aW9uJyxcbiAgICB0cmFuc2FjdGlvblxuICB9KTtcblxuICBjb25zdCB0cmFuc2FjdGlvbk9iaiA9IHtcbiAgICBkZXRhaWxzOiBuZXdTdGF0ZSxcbiAgICBlbWl0dGVyXG4gIH07XG5cbiAgZnVuY3Rpb24gZW1pdFN0YXRlKCkge1xuICAgIGNvbnN0IGVtaXR0ZXJSZXN1bHQgPSBlbWl0dGVyLmVtaXQobmV3U3RhdGUpO1xuXG4gICAgdGhpcy5fdHJhbnNhY3Rpb25IYW5kbGVycy5mb3JFYWNoKGhhbmRsZXIgPT4gaGFuZGxlcih7XG4gICAgICB0cmFuc2FjdGlvbjogbmV3U3RhdGUsXG4gICAgICBlbWl0dGVyUmVzdWx0XG4gICAgfSkpO1xuICB9IC8vIGVtaXQgYWZ0ZXIgZGVsYXkgdG8gYWxsb3cgZm9yIGxpc3RlbmVyIHRvIGJlIHJlZ2lzdGVyZWRcblxuXG4gIHNldFRpbWVvdXQoZW1pdFN0YXRlLmJpbmQodGhpcyksIDUpO1xuICByZXR1cm4gdHJhbnNhY3Rpb25PYmo7XG59XG5cbmZ1bmN0aW9uIGFjY291bnQoYWRkcmVzcykge1xuICBpZiAodGhpcy5fZGVzdHJveWVkKSB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBXZWJTb2NrZXQgaW5zdGFuY2UgaGFzIGJlZW4gZGVzdHJveWVkLCByZS1pbml0aWFsaXplIHRvIGNvbnRpbnVlIG1ha2luZyByZXF1ZXN0cy4nKTsgLy8gbG93ZXJjYXNlIHRoZSBhZGRyZXNzIGlmIEV0aGVyZXVtXG5cbiAgYWRkcmVzcyA9IHRoaXMuX3N5c3RlbSA9PT0gJ2V0aGVyZXVtJyA/IGFkZHJlc3MudG9Mb3dlckNhc2UoKSA6IGFkZHJlc3M7IC8vIGNyZWF0ZSBlbWl0dGVyIGZvciB0cmFuc2FjdGlvblxuXG4gIGNvbnN0IGVtaXR0ZXIgPSBjcmVhdGVFbWl0dGVyKCk7IC8vIGNyZWF0ZSBldmVudENvZGUgZm9yIHRyYW5zYWN0aW9uXG5cbiAgY29uc3QgZXZlbnRDb2RlID0gJ3dhdGNoJztcbiAgY29uc3QgZXhpc3RpbmdBZGRyZXNzV2F0Y2hlciA9IHRoaXMud2F0Y2hlZEFjY291bnRzLmZpbmQoYWMgPT4gYWMuYWRkcmVzcyA9PT0gYWRkcmVzcyk7XG5cbiAgaWYgKGV4aXN0aW5nQWRkcmVzc1dhdGNoZXIpIHtcbiAgICAvLyBhZGQgdG8gZXhpc3RpbmcgZW1pdHRlcnMgYXJyYXlcbiAgICBleGlzdGluZ0FkZHJlc3NXYXRjaGVyLmVtaXR0ZXJzLnB1c2goZW1pdHRlcik7XG4gIH0gZWxzZSB7XG4gICAgLy8gcHV0IGluIGFjY291bnRzIHF1ZXVlXG4gICAgdGhpcy53YXRjaGVkQWNjb3VudHMucHVzaCh7XG4gICAgICBhZGRyZXNzLFxuICAgICAgZW1pdHRlcnM6IFtlbWl0dGVyXVxuICAgIH0pO1xuICB9IC8vIGxvZ0V2ZW50IHRvIHNlcnZlclxuXG5cbiAgdGhpcy5fc2VuZE1lc3NhZ2Uoe1xuICAgIGV2ZW50Q29kZSxcbiAgICBjYXRlZ29yeUNvZGU6ICdhY2NvdW50QWRkcmVzcycsXG4gICAgYWNjb3VudDoge1xuICAgICAgYWRkcmVzc1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHtcbiAgICBlbWl0dGVyLFxuICAgIGRldGFpbHM6IHtcbiAgICAgIGFkZHJlc3NcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGV2ZW50KGV2ZW50T2JqKSB7XG4gIGlmICh0aGlzLl9kZXN0cm95ZWQpIHRocm93IG5ldyBFcnJvcignVGhlIFdlYlNvY2tldCBpbnN0YW5jZSBoYXMgYmVlbiBkZXN0cm95ZWQsIHJlLWluaXRpYWxpemUgdG8gY29udGludWUgbWFraW5nIHJlcXVlc3RzLicpO1xuXG4gIHRoaXMuX3NlbmRNZXNzYWdlKGV2ZW50T2JqKTtcbn1cbi8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlXHJcbnRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlXHJcbkxpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcblxyXG5USElTIENPREUgSVMgUFJPVklERUQgT04gQU4gKkFTIElTKiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbktJTkQsIEVJVEhFUiBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBXSVRIT1VUIExJTUlUQVRJT04gQU5ZIElNUExJRURcclxuV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIFRJVExFLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSxcclxuTUVSQ0hBTlRBQkxJVFkgT1IgTk9OLUlORlJJTkdFTUVOVC5cclxuXHJcblNlZSB0aGUgQXBhY2hlIFZlcnNpb24gMi4wIExpY2Vuc2UgZm9yIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9uc1xyXG5hbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXG5cbi8qIGdsb2JhbCBSZWZsZWN0LCBQcm9taXNlICovXG5cblxudmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IHtcbiAgICBfX3Byb3RvX186IFtdXG4gIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikge1xuICAgIGQuX19wcm90b19fID0gYjtcbiAgfSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICB9O1xuXG4gIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xufTtcblxuZnVuY3Rpb24gX19leHRlbmRzKGQsIGIpIHtcbiAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcblxuICBmdW5jdGlvbiBfXygpIHtcbiAgICB0aGlzLmNvbnN0cnVjdG9yID0gZDtcbiAgfVxuXG4gIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn1cbi8qKiBQVVJFX0lNUE9SVFNfU1RBUlQgIFBVUkVfSU1QT1JUU19FTkQgKi9cblxuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIHR5cGVvZiB4ID09PSAnZnVuY3Rpb24nO1xufVxuLyoqIFBVUkVfSU1QT1JUU19TVEFSVCAgUFVSRV9JTVBPUlRTX0VORCAqL1xuXG5cbnZhciBfZW5hYmxlX3N1cGVyX2dyb3NzX21vZGVfdGhhdF93aWxsX2NhdXNlX2JhZF90aGluZ3MgPSBmYWxzZTtcbnZhciBjb25maWcgPSB7XG4gIFByb21pc2U6IHVuZGVmaW5lZCxcblxuICBzZXQgdXNlRGVwcmVjYXRlZFN5bmNocm9ub3VzRXJyb3JIYW5kbGluZyh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgdmFyIGVycm9yID0gLypAX19QVVJFX18qL25ldyBFcnJvcigpO1xuICAgICAgLypAX19QVVJFX18qL1xuXG4gICAgICBjb25zb2xlLndhcm4oJ0RFUFJFQ0FURUQhIFJ4SlMgd2FzIHNldCB0byB1c2UgZGVwcmVjYXRlZCBzeW5jaHJvbm91cyBlcnJvciBoYW5kbGluZyBiZWhhdmlvciBieSBjb2RlIGF0OiBcXG4nICsgZXJyb3Iuc3RhY2spO1xuICAgIH1cblxuICAgIF9lbmFibGVfc3VwZXJfZ3Jvc3NfbW9kZV90aGF0X3dpbGxfY2F1c2VfYmFkX3RoaW5ncyA9IHZhbHVlO1xuICB9LFxuXG4gIGdldCB1c2VEZXByZWNhdGVkU3luY2hyb25vdXNFcnJvckhhbmRsaW5nKCkge1xuICAgIHJldHVybiBfZW5hYmxlX3N1cGVyX2dyb3NzX21vZGVfdGhhdF93aWxsX2NhdXNlX2JhZF90aGluZ3M7XG4gIH1cblxufTtcbi8qKiBQVVJFX0lNUE9SVFNfU1RBUlQgIFBVUkVfSU1QT1JUU19FTkQgKi9cblxuZnVuY3Rpb24gaG9zdFJlcG9ydEVycm9yKGVycikge1xuICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICB0aHJvdyBlcnI7XG4gIH0sIDApO1xufVxuLyoqIFBVUkVfSU1QT1JUU19TVEFSVCBfY29uZmlnLF91dGlsX2hvc3RSZXBvcnRFcnJvciBQVVJFX0lNUE9SVFNfRU5EICovXG5cblxudmFyIGVtcHR5ID0ge1xuICBjbG9zZWQ6IHRydWUsXG4gIG5leHQ6IGZ1bmN0aW9uICh2YWx1ZSkge30sXG4gIGVycm9yOiBmdW5jdGlvbiAoZXJyKSB7XG4gICAgaWYgKGNvbmZpZy51c2VEZXByZWNhdGVkU3luY2hyb25vdXNFcnJvckhhbmRsaW5nKSB7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGhvc3RSZXBvcnRFcnJvcihlcnIpO1xuICAgIH1cbiAgfSxcbiAgY29tcGxldGU6IGZ1bmN0aW9uICgpIHt9XG59O1xuLyoqIFBVUkVfSU1QT1JUU19TVEFSVCAgUFVSRV9JTVBPUlRTX0VORCAqL1xuXG52YXIgaXNBcnJheSA9IC8qQF9fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uICh4KSB7XG4gICAgcmV0dXJuIHggJiYgdHlwZW9mIHgubGVuZ3RoID09PSAnbnVtYmVyJztcbiAgfTtcbn0oKTtcbi8qKiBQVVJFX0lNUE9SVFNfU1RBUlQgIFBVUkVfSU1QT1JUU19FTkQgKi9cblxuXG5mdW5jdGlvbiBpc09iamVjdCh4KSB7XG4gIHJldHVybiB4ICE9PSBudWxsICYmIHR5cGVvZiB4ID09PSAnb2JqZWN0Jztcbn1cbi8qKiBQVVJFX0lNUE9SVFNfU1RBUlQgIFBVUkVfSU1QT1JUU19FTkQgKi9cblxuXG52YXIgVW5zdWJzY3JpcHRpb25FcnJvckltcGwgPSAvKkBfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBVbnN1YnNjcmlwdGlvbkVycm9ySW1wbChlcnJvcnMpIHtcbiAgICBFcnJvci5jYWxsKHRoaXMpO1xuICAgIHRoaXMubWVzc2FnZSA9IGVycm9ycyA/IGVycm9ycy5sZW5ndGggKyBcIiBlcnJvcnMgb2NjdXJyZWQgZHVyaW5nIHVuc3Vic2NyaXB0aW9uOlxcblwiICsgZXJyb3JzLm1hcChmdW5jdGlvbiAoZXJyLCBpKSB7XG4gICAgICByZXR1cm4gaSArIDEgKyBcIikgXCIgKyBlcnIudG9TdHJpbmcoKTtcbiAgICB9KS5qb2luKCdcXG4gICcpIDogJyc7XG4gICAgdGhpcy5uYW1lID0gJ1Vuc3Vic2NyaXB0aW9uRXJyb3InO1xuICAgIHRoaXMuZXJyb3JzID0gZXJyb3JzO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgVW5zdWJzY3JpcHRpb25FcnJvckltcGwucHJvdG90eXBlID0gLypAX19QVVJFX18qL09iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlKTtcbiAgcmV0dXJuIFVuc3Vic2NyaXB0aW9uRXJyb3JJbXBsO1xufSgpO1xuXG52YXIgVW5zdWJzY3JpcHRpb25FcnJvciA9IFVuc3Vic2NyaXB0aW9uRXJyb3JJbXBsO1xuLyoqIFBVUkVfSU1QT1JUU19TVEFSVCBfdXRpbF9pc0FycmF5LF91dGlsX2lzT2JqZWN0LF91dGlsX2lzRnVuY3Rpb24sX3V0aWxfVW5zdWJzY3JpcHRpb25FcnJvciBQVVJFX0lNUE9SVFNfRU5EICovXG5cbnZhciBTdWJzY3JpcHRpb24gPSAvKkBfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBTdWJzY3JpcHRpb24odW5zdWJzY3JpYmUpIHtcbiAgICB0aGlzLmNsb3NlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3BhcmVudE9yUGFyZW50cyA9IG51bGw7XG4gICAgdGhpcy5fc3Vic2NyaXB0aW9ucyA9IG51bGw7XG5cbiAgICBpZiAodW5zdWJzY3JpYmUpIHtcbiAgICAgIHRoaXMuX2N0b3JVbnN1YnNjcmliZSA9IHRydWU7XG4gICAgICB0aGlzLl91bnN1YnNjcmliZSA9IHVuc3Vic2NyaWJlO1xuICAgIH1cbiAgfVxuXG4gIFN1YnNjcmlwdGlvbi5wcm90b3R5cGUudW5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGVycm9ycztcblxuICAgIGlmICh0aGlzLmNsb3NlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBfYSA9IHRoaXMsXG4gICAgICAgIF9wYXJlbnRPclBhcmVudHMgPSBfYS5fcGFyZW50T3JQYXJlbnRzLFxuICAgICAgICBfY3RvclVuc3Vic2NyaWJlID0gX2EuX2N0b3JVbnN1YnNjcmliZSxcbiAgICAgICAgX3Vuc3Vic2NyaWJlID0gX2EuX3Vuc3Vic2NyaWJlLFxuICAgICAgICBfc3Vic2NyaXB0aW9ucyA9IF9hLl9zdWJzY3JpcHRpb25zO1xuXG4gICAgdGhpcy5jbG9zZWQgPSB0cnVlO1xuICAgIHRoaXMuX3BhcmVudE9yUGFyZW50cyA9IG51bGw7XG4gICAgdGhpcy5fc3Vic2NyaXB0aW9ucyA9IG51bGw7XG5cbiAgICBpZiAoX3BhcmVudE9yUGFyZW50cyBpbnN0YW5jZW9mIFN1YnNjcmlwdGlvbikge1xuICAgICAgX3BhcmVudE9yUGFyZW50cy5yZW1vdmUodGhpcyk7XG4gICAgfSBlbHNlIGlmIChfcGFyZW50T3JQYXJlbnRzICE9PSBudWxsKSB7XG4gICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgX3BhcmVudE9yUGFyZW50cy5sZW5ndGg7ICsraW5kZXgpIHtcbiAgICAgICAgdmFyIHBhcmVudF8xID0gX3BhcmVudE9yUGFyZW50c1tpbmRleF07XG4gICAgICAgIHBhcmVudF8xLnJlbW92ZSh0aGlzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaXNGdW5jdGlvbihfdW5zdWJzY3JpYmUpKSB7XG4gICAgICBpZiAoX2N0b3JVbnN1YnNjcmliZSkge1xuICAgICAgICB0aGlzLl91bnN1YnNjcmliZSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgdHJ5IHtcbiAgICAgICAgX3Vuc3Vic2NyaWJlLmNhbGwodGhpcyk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGVycm9ycyA9IGUgaW5zdGFuY2VvZiBVbnN1YnNjcmlwdGlvbkVycm9yID8gZmxhdHRlblVuc3Vic2NyaXB0aW9uRXJyb3JzKGUuZXJyb3JzKSA6IFtlXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaXNBcnJheShfc3Vic2NyaXB0aW9ucykpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xO1xuICAgICAgdmFyIGxlbiA9IF9zdWJzY3JpcHRpb25zLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW4pIHtcbiAgICAgICAgdmFyIHN1YiA9IF9zdWJzY3JpcHRpb25zW2luZGV4XTtcblxuICAgICAgICBpZiAoaXNPYmplY3Qoc3ViKSkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBzdWIudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBlcnJvcnMgPSBlcnJvcnMgfHwgW107XG5cbiAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgVW5zdWJzY3JpcHRpb25FcnJvcikge1xuICAgICAgICAgICAgICBlcnJvcnMgPSBlcnJvcnMuY29uY2F0KGZsYXR0ZW5VbnN1YnNjcmlwdGlvbkVycm9ycyhlLmVycm9ycykpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZXJyb3JzLnB1c2goZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGVycm9ycykge1xuICAgICAgdGhyb3cgbmV3IFVuc3Vic2NyaXB0aW9uRXJyb3IoZXJyb3JzKTtcbiAgICB9XG4gIH07XG5cbiAgU3Vic2NyaXB0aW9uLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAodGVhcmRvd24pIHtcbiAgICB2YXIgc3Vic2NyaXB0aW9uID0gdGVhcmRvd247XG5cbiAgICBpZiAoIXRlYXJkb3duKSB7XG4gICAgICByZXR1cm4gU3Vic2NyaXB0aW9uLkVNUFRZO1xuICAgIH1cblxuICAgIHN3aXRjaCAodHlwZW9mIHRlYXJkb3duKSB7XG4gICAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgICAgIHN1YnNjcmlwdGlvbiA9IG5ldyBTdWJzY3JpcHRpb24odGVhcmRvd24pO1xuXG4gICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICBpZiAoc3Vic2NyaXB0aW9uID09PSB0aGlzIHx8IHN1YnNjcmlwdGlvbi5jbG9zZWQgfHwgdHlwZW9mIHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHJldHVybiBzdWJzY3JpcHRpb247XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5jbG9zZWQpIHtcbiAgICAgICAgICBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICByZXR1cm4gc3Vic2NyaXB0aW9uO1xuICAgICAgICB9IGVsc2UgaWYgKCEoc3Vic2NyaXB0aW9uIGluc3RhbmNlb2YgU3Vic2NyaXB0aW9uKSkge1xuICAgICAgICAgIHZhciB0bXAgPSBzdWJzY3JpcHRpb247XG4gICAgICAgICAgc3Vic2NyaXB0aW9uID0gbmV3IFN1YnNjcmlwdGlvbigpO1xuICAgICAgICAgIHN1YnNjcmlwdGlvbi5fc3Vic2NyaXB0aW9ucyA9IFt0bXBdO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VucmVjb2duaXplZCB0ZWFyZG93biAnICsgdGVhcmRvd24gKyAnIGFkZGVkIHRvIFN1YnNjcmlwdGlvbi4nKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBfcGFyZW50T3JQYXJlbnRzID0gc3Vic2NyaXB0aW9uLl9wYXJlbnRPclBhcmVudHM7XG5cbiAgICBpZiAoX3BhcmVudE9yUGFyZW50cyA9PT0gbnVsbCkge1xuICAgICAgc3Vic2NyaXB0aW9uLl9wYXJlbnRPclBhcmVudHMgPSB0aGlzO1xuICAgIH0gZWxzZSBpZiAoX3BhcmVudE9yUGFyZW50cyBpbnN0YW5jZW9mIFN1YnNjcmlwdGlvbikge1xuICAgICAgaWYgKF9wYXJlbnRPclBhcmVudHMgPT09IHRoaXMpIHtcbiAgICAgICAgcmV0dXJuIHN1YnNjcmlwdGlvbjtcbiAgICAgIH1cblxuICAgICAgc3Vic2NyaXB0aW9uLl9wYXJlbnRPclBhcmVudHMgPSBbX3BhcmVudE9yUGFyZW50cywgdGhpc107XG4gICAgfSBlbHNlIGlmIChfcGFyZW50T3JQYXJlbnRzLmluZGV4T2YodGhpcykgPT09IC0xKSB7XG4gICAgICBfcGFyZW50T3JQYXJlbnRzLnB1c2godGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBzdWJzY3JpcHRpb247XG4gICAgfVxuXG4gICAgdmFyIHN1YnNjcmlwdGlvbnMgPSB0aGlzLl9zdWJzY3JpcHRpb25zO1xuXG4gICAgaWYgKHN1YnNjcmlwdGlvbnMgPT09IG51bGwpIHtcbiAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbnMgPSBbc3Vic2NyaXB0aW9uXTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3Vic2NyaXB0aW9ucy5wdXNoKHN1YnNjcmlwdGlvbik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN1YnNjcmlwdGlvbjtcbiAgfTtcblxuICBTdWJzY3JpcHRpb24ucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChzdWJzY3JpcHRpb24pIHtcbiAgICB2YXIgc3Vic2NyaXB0aW9ucyA9IHRoaXMuX3N1YnNjcmlwdGlvbnM7XG5cbiAgICBpZiAoc3Vic2NyaXB0aW9ucykge1xuICAgICAgdmFyIHN1YnNjcmlwdGlvbkluZGV4ID0gc3Vic2NyaXB0aW9ucy5pbmRleE9mKHN1YnNjcmlwdGlvbik7XG5cbiAgICAgIGlmIChzdWJzY3JpcHRpb25JbmRleCAhPT0gLTEpIHtcbiAgICAgICAgc3Vic2NyaXB0aW9ucy5zcGxpY2Uoc3Vic2NyaXB0aW9uSW5kZXgsIDEpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBTdWJzY3JpcHRpb24uRU1QVFkgPSBmdW5jdGlvbiAoZW1wdHkpIHtcbiAgICBlbXB0eS5jbG9zZWQgPSB0cnVlO1xuICAgIHJldHVybiBlbXB0eTtcbiAgfShuZXcgU3Vic2NyaXB0aW9uKCkpO1xuXG4gIHJldHVybiBTdWJzY3JpcHRpb247XG59KCk7XG5cbmZ1bmN0aW9uIGZsYXR0ZW5VbnN1YnNjcmlwdGlvbkVycm9ycyhlcnJvcnMpIHtcbiAgcmV0dXJuIGVycm9ycy5yZWR1Y2UoZnVuY3Rpb24gKGVycnMsIGVycikge1xuICAgIHJldHVybiBlcnJzLmNvbmNhdChlcnIgaW5zdGFuY2VvZiBVbnN1YnNjcmlwdGlvbkVycm9yID8gZXJyLmVycm9ycyA6IGVycik7XG4gIH0sIFtdKTtcbn1cbi8qKiBQVVJFX0lNUE9SVFNfU1RBUlQgIFBVUkVfSU1QT1JUU19FTkQgKi9cblxuXG52YXIgcnhTdWJzY3JpYmVyID0gLypAX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgPyAvKkBfX1BVUkVfXyovU3ltYm9sKCdyeFN1YnNjcmliZXInKSA6ICdAQHJ4U3Vic2NyaWJlcl8nICsgLypAX19QVVJFX18qL01hdGgucmFuZG9tKCk7XG59KCk7XG4vKiogUFVSRV9JTVBPUlRTX1NUQVJUIHRzbGliLF91dGlsX2lzRnVuY3Rpb24sX09ic2VydmVyLF9TdWJzY3JpcHRpb24sX2ludGVybmFsX3N5bWJvbF9yeFN1YnNjcmliZXIsX2NvbmZpZyxfdXRpbF9ob3N0UmVwb3J0RXJyb3IgUFVSRV9JTVBPUlRTX0VORCAqL1xuXG5cbnZhciBTdWJzY3JpYmVyID0gLypAX19QVVJFX18qL2Z1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKFN1YnNjcmliZXIsIF9zdXBlcik7XG5cbiAgZnVuY3Rpb24gU3Vic2NyaWJlcihkZXN0aW5hdGlvbk9yTmV4dCwgZXJyb3IsIGNvbXBsZXRlKSB7XG4gICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcblxuICAgIF90aGlzLnN5bmNFcnJvclZhbHVlID0gbnVsbDtcbiAgICBfdGhpcy5zeW5jRXJyb3JUaHJvd24gPSBmYWxzZTtcbiAgICBfdGhpcy5zeW5jRXJyb3JUaHJvd2FibGUgPSBmYWxzZTtcbiAgICBfdGhpcy5pc1N0b3BwZWQgPSBmYWxzZTtcblxuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgY2FzZSAwOlxuICAgICAgICBfdGhpcy5kZXN0aW5hdGlvbiA9IGVtcHR5O1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAxOlxuICAgICAgICBpZiAoIWRlc3RpbmF0aW9uT3JOZXh0KSB7XG4gICAgICAgICAgX3RoaXMuZGVzdGluYXRpb24gPSBlbXB0eTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgZGVzdGluYXRpb25Pck5leHQgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgaWYgKGRlc3RpbmF0aW9uT3JOZXh0IGluc3RhbmNlb2YgU3Vic2NyaWJlcikge1xuICAgICAgICAgICAgX3RoaXMuc3luY0Vycm9yVGhyb3dhYmxlID0gZGVzdGluYXRpb25Pck5leHQuc3luY0Vycm9yVGhyb3dhYmxlO1xuICAgICAgICAgICAgX3RoaXMuZGVzdGluYXRpb24gPSBkZXN0aW5hdGlvbk9yTmV4dDtcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uT3JOZXh0LmFkZChfdGhpcyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIF90aGlzLnN5bmNFcnJvclRocm93YWJsZSA9IHRydWU7XG4gICAgICAgICAgICBfdGhpcy5kZXN0aW5hdGlvbiA9IG5ldyBTYWZlU3Vic2NyaWJlcihfdGhpcywgZGVzdGluYXRpb25Pck5leHQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIF90aGlzLnN5bmNFcnJvclRocm93YWJsZSA9IHRydWU7XG4gICAgICAgIF90aGlzLmRlc3RpbmF0aW9uID0gbmV3IFNhZmVTdWJzY3JpYmVyKF90aGlzLCBkZXN0aW5hdGlvbk9yTmV4dCwgZXJyb3IsIGNvbXBsZXRlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgU3Vic2NyaWJlci5wcm90b3R5cGVbcnhTdWJzY3JpYmVyXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBTdWJzY3JpYmVyLmNyZWF0ZSA9IGZ1bmN0aW9uIChuZXh0LCBlcnJvciwgY29tcGxldGUpIHtcbiAgICB2YXIgc3Vic2NyaWJlciA9IG5ldyBTdWJzY3JpYmVyKG5leHQsIGVycm9yLCBjb21wbGV0ZSk7XG4gICAgc3Vic2NyaWJlci5zeW5jRXJyb3JUaHJvd2FibGUgPSBmYWxzZTtcbiAgICByZXR1cm4gc3Vic2NyaWJlcjtcbiAgfTtcblxuICBTdWJzY3JpYmVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgaWYgKCF0aGlzLmlzU3RvcHBlZCkge1xuICAgICAgdGhpcy5fbmV4dCh2YWx1ZSk7XG4gICAgfVxuICB9O1xuXG4gIFN1YnNjcmliZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgIGlmICghdGhpcy5pc1N0b3BwZWQpIHtcbiAgICAgIHRoaXMuaXNTdG9wcGVkID0gdHJ1ZTtcblxuICAgICAgdGhpcy5fZXJyb3IoZXJyKTtcbiAgICB9XG4gIH07XG5cbiAgU3Vic2NyaWJlci5wcm90b3R5cGUuY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF0aGlzLmlzU3RvcHBlZCkge1xuICAgICAgdGhpcy5pc1N0b3BwZWQgPSB0cnVlO1xuXG4gICAgICB0aGlzLl9jb21wbGV0ZSgpO1xuICAgIH1cbiAgfTtcblxuICBTdWJzY3JpYmVyLnByb3RvdHlwZS51bnN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5jbG9zZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmlzU3RvcHBlZCA9IHRydWU7XG5cbiAgICBfc3VwZXIucHJvdG90eXBlLnVuc3Vic2NyaWJlLmNhbGwodGhpcyk7XG4gIH07XG5cbiAgU3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQodmFsdWUpO1xuICB9O1xuXG4gIFN1YnNjcmliZXIucHJvdG90eXBlLl9lcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICB0aGlzLmRlc3RpbmF0aW9uLmVycm9yKGVycik7XG4gICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICB9O1xuXG4gIFN1YnNjcmliZXIucHJvdG90eXBlLl9jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG4gICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICB9O1xuXG4gIFN1YnNjcmliZXIucHJvdG90eXBlLl91bnN1YnNjcmliZUFuZFJlY3ljbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF9wYXJlbnRPclBhcmVudHMgPSB0aGlzLl9wYXJlbnRPclBhcmVudHM7XG4gICAgdGhpcy5fcGFyZW50T3JQYXJlbnRzID0gbnVsbDtcbiAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgdGhpcy5jbG9zZWQgPSBmYWxzZTtcbiAgICB0aGlzLmlzU3RvcHBlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3BhcmVudE9yUGFyZW50cyA9IF9wYXJlbnRPclBhcmVudHM7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgcmV0dXJuIFN1YnNjcmliZXI7XG59KFN1YnNjcmlwdGlvbik7XG5cbnZhciBTYWZlU3Vic2NyaWJlciA9IC8qQF9fUFVSRV9fKi9mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhTYWZlU3Vic2NyaWJlciwgX3N1cGVyKTtcblxuICBmdW5jdGlvbiBTYWZlU3Vic2NyaWJlcihfcGFyZW50U3Vic2NyaWJlciwgb2JzZXJ2ZXJPck5leHQsIGVycm9yLCBjb21wbGV0ZSkge1xuICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG5cbiAgICBfdGhpcy5fcGFyZW50U3Vic2NyaWJlciA9IF9wYXJlbnRTdWJzY3JpYmVyO1xuICAgIHZhciBuZXh0O1xuICAgIHZhciBjb250ZXh0ID0gX3RoaXM7XG5cbiAgICBpZiAoaXNGdW5jdGlvbihvYnNlcnZlck9yTmV4dCkpIHtcbiAgICAgIG5leHQgPSBvYnNlcnZlck9yTmV4dDtcbiAgICB9IGVsc2UgaWYgKG9ic2VydmVyT3JOZXh0KSB7XG4gICAgICBuZXh0ID0gb2JzZXJ2ZXJPck5leHQubmV4dDtcbiAgICAgIGVycm9yID0gb2JzZXJ2ZXJPck5leHQuZXJyb3I7XG4gICAgICBjb21wbGV0ZSA9IG9ic2VydmVyT3JOZXh0LmNvbXBsZXRlO1xuXG4gICAgICBpZiAob2JzZXJ2ZXJPck5leHQgIT09IGVtcHR5KSB7XG4gICAgICAgIGNvbnRleHQgPSBPYmplY3QuY3JlYXRlKG9ic2VydmVyT3JOZXh0KTtcblxuICAgICAgICBpZiAoaXNGdW5jdGlvbihjb250ZXh0LnVuc3Vic2NyaWJlKSkge1xuICAgICAgICAgIF90aGlzLmFkZChjb250ZXh0LnVuc3Vic2NyaWJlLmJpbmQoY29udGV4dCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29udGV4dC51bnN1YnNjcmliZSA9IF90aGlzLnVuc3Vic2NyaWJlLmJpbmQoX3RoaXMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIF90aGlzLl9jb250ZXh0ID0gY29udGV4dDtcbiAgICBfdGhpcy5fbmV4dCA9IG5leHQ7XG4gICAgX3RoaXMuX2Vycm9yID0gZXJyb3I7XG4gICAgX3RoaXMuX2NvbXBsZXRlID0gY29tcGxldGU7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgU2FmZVN1YnNjcmliZXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBpZiAoIXRoaXMuaXNTdG9wcGVkICYmIHRoaXMuX25leHQpIHtcbiAgICAgIHZhciBfcGFyZW50U3Vic2NyaWJlciA9IHRoaXMuX3BhcmVudFN1YnNjcmliZXI7XG5cbiAgICAgIGlmICghY29uZmlnLnVzZURlcHJlY2F0ZWRTeW5jaHJvbm91c0Vycm9ySGFuZGxpbmcgfHwgIV9wYXJlbnRTdWJzY3JpYmVyLnN5bmNFcnJvclRocm93YWJsZSkge1xuICAgICAgICB0aGlzLl9fdHJ5T3JVbnN1Yih0aGlzLl9uZXh0LCB2YWx1ZSk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX190cnlPclNldEVycm9yKF9wYXJlbnRTdWJzY3JpYmVyLCB0aGlzLl9uZXh0LCB2YWx1ZSkpIHtcbiAgICAgICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBTYWZlU3Vic2NyaWJlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgaWYgKCF0aGlzLmlzU3RvcHBlZCkge1xuICAgICAgdmFyIF9wYXJlbnRTdWJzY3JpYmVyID0gdGhpcy5fcGFyZW50U3Vic2NyaWJlcjtcbiAgICAgIHZhciB1c2VEZXByZWNhdGVkU3luY2hyb25vdXNFcnJvckhhbmRsaW5nID0gY29uZmlnLnVzZURlcHJlY2F0ZWRTeW5jaHJvbm91c0Vycm9ySGFuZGxpbmc7XG5cbiAgICAgIGlmICh0aGlzLl9lcnJvcikge1xuICAgICAgICBpZiAoIXVzZURlcHJlY2F0ZWRTeW5jaHJvbm91c0Vycm9ySGFuZGxpbmcgfHwgIV9wYXJlbnRTdWJzY3JpYmVyLnN5bmNFcnJvclRocm93YWJsZSkge1xuICAgICAgICAgIHRoaXMuX190cnlPclVuc3ViKHRoaXMuX2Vycm9yLCBlcnIpO1xuXG4gICAgICAgICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX190cnlPclNldEVycm9yKF9wYXJlbnRTdWJzY3JpYmVyLCB0aGlzLl9lcnJvciwgZXJyKTtcblxuICAgICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICghX3BhcmVudFN1YnNjcmliZXIuc3luY0Vycm9yVGhyb3dhYmxlKSB7XG4gICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcblxuICAgICAgICBpZiAodXNlRGVwcmVjYXRlZFN5bmNocm9ub3VzRXJyb3JIYW5kbGluZykge1xuICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuXG4gICAgICAgIGhvc3RSZXBvcnRFcnJvcihlcnIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHVzZURlcHJlY2F0ZWRTeW5jaHJvbm91c0Vycm9ySGFuZGxpbmcpIHtcbiAgICAgICAgICBfcGFyZW50U3Vic2NyaWJlci5zeW5jRXJyb3JWYWx1ZSA9IGVycjtcbiAgICAgICAgICBfcGFyZW50U3Vic2NyaWJlci5zeW5jRXJyb3JUaHJvd24gPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGhvc3RSZXBvcnRFcnJvcihlcnIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBTYWZlU3Vic2NyaWJlci5wcm90b3R5cGUuY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIGlmICghdGhpcy5pc1N0b3BwZWQpIHtcbiAgICAgIHZhciBfcGFyZW50U3Vic2NyaWJlciA9IHRoaXMuX3BhcmVudFN1YnNjcmliZXI7XG5cbiAgICAgIGlmICh0aGlzLl9jb21wbGV0ZSkge1xuICAgICAgICB2YXIgd3JhcHBlZENvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBfdGhpcy5fY29tcGxldGUuY2FsbChfdGhpcy5fY29udGV4dCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKCFjb25maWcudXNlRGVwcmVjYXRlZFN5bmNocm9ub3VzRXJyb3JIYW5kbGluZyB8fCAhX3BhcmVudFN1YnNjcmliZXIuc3luY0Vycm9yVGhyb3dhYmxlKSB7XG4gICAgICAgICAgdGhpcy5fX3RyeU9yVW5zdWIod3JhcHBlZENvbXBsZXRlKTtcblxuICAgICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9fdHJ5T3JTZXRFcnJvcihfcGFyZW50U3Vic2NyaWJlciwgd3JhcHBlZENvbXBsZXRlKTtcblxuICAgICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBTYWZlU3Vic2NyaWJlci5wcm90b3R5cGUuX190cnlPclVuc3ViID0gZnVuY3Rpb24gKGZuLCB2YWx1ZSkge1xuICAgIHRyeSB7XG4gICAgICBmbi5jYWxsKHRoaXMuX2NvbnRleHQsIHZhbHVlKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcblxuICAgICAgaWYgKGNvbmZpZy51c2VEZXByZWNhdGVkU3luY2hyb25vdXNFcnJvckhhbmRsaW5nKSB7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGhvc3RSZXBvcnRFcnJvcihlcnIpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBTYWZlU3Vic2NyaWJlci5wcm90b3R5cGUuX190cnlPclNldEVycm9yID0gZnVuY3Rpb24gKHBhcmVudCwgZm4sIHZhbHVlKSB7XG4gICAgaWYgKCFjb25maWcudXNlRGVwcmVjYXRlZFN5bmNocm9ub3VzRXJyb3JIYW5kbGluZykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgY2FsbCcpO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBmbi5jYWxsKHRoaXMuX2NvbnRleHQsIHZhbHVlKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGlmIChjb25maWcudXNlRGVwcmVjYXRlZFN5bmNocm9ub3VzRXJyb3JIYW5kbGluZykge1xuICAgICAgICBwYXJlbnQuc3luY0Vycm9yVmFsdWUgPSBlcnI7XG4gICAgICAgIHBhcmVudC5zeW5jRXJyb3JUaHJvd24gPSB0cnVlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGhvc3RSZXBvcnRFcnJvcihlcnIpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgU2FmZVN1YnNjcmliZXIucHJvdG90eXBlLl91bnN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX3BhcmVudFN1YnNjcmliZXIgPSB0aGlzLl9wYXJlbnRTdWJzY3JpYmVyO1xuICAgIHRoaXMuX2NvbnRleHQgPSBudWxsO1xuICAgIHRoaXMuX3BhcmVudFN1YnNjcmliZXIgPSBudWxsO1xuXG4gICAgX3BhcmVudFN1YnNjcmliZXIudW5zdWJzY3JpYmUoKTtcbiAgfTtcblxuICByZXR1cm4gU2FmZVN1YnNjcmliZXI7XG59KFN1YnNjcmliZXIpO1xuLyoqIFBVUkVfSU1QT1JUU19TVEFSVCBfU3Vic2NyaWJlciBQVVJFX0lNUE9SVFNfRU5EICovXG5cblxuZnVuY3Rpb24gY2FuUmVwb3J0RXJyb3Iob2JzZXJ2ZXIpIHtcbiAgd2hpbGUgKG9ic2VydmVyKSB7XG4gICAgdmFyIF9hID0gb2JzZXJ2ZXIsXG4gICAgICAgIGNsb3NlZF8xID0gX2EuY2xvc2VkLFxuICAgICAgICBkZXN0aW5hdGlvbiA9IF9hLmRlc3RpbmF0aW9uLFxuICAgICAgICBpc1N0b3BwZWQgPSBfYS5pc1N0b3BwZWQ7XG5cbiAgICBpZiAoY2xvc2VkXzEgfHwgaXNTdG9wcGVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChkZXN0aW5hdGlvbiAmJiBkZXN0aW5hdGlvbiBpbnN0YW5jZW9mIFN1YnNjcmliZXIpIHtcbiAgICAgIG9ic2VydmVyID0gZGVzdGluYXRpb247XG4gICAgfSBlbHNlIHtcbiAgICAgIG9ic2VydmVyID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cbi8qKiBQVVJFX0lNUE9SVFNfU1RBUlQgX1N1YnNjcmliZXIsX3N5bWJvbF9yeFN1YnNjcmliZXIsX09ic2VydmVyIFBVUkVfSU1QT1JUU19FTkQgKi9cblxuXG5mdW5jdGlvbiB0b1N1YnNjcmliZXIobmV4dE9yT2JzZXJ2ZXIsIGVycm9yLCBjb21wbGV0ZSkge1xuICBpZiAobmV4dE9yT2JzZXJ2ZXIpIHtcbiAgICBpZiAobmV4dE9yT2JzZXJ2ZXIgaW5zdGFuY2VvZiBTdWJzY3JpYmVyKSB7XG4gICAgICByZXR1cm4gbmV4dE9yT2JzZXJ2ZXI7XG4gICAgfVxuXG4gICAgaWYgKG5leHRPck9ic2VydmVyW3J4U3Vic2NyaWJlcl0pIHtcbiAgICAgIHJldHVybiBuZXh0T3JPYnNlcnZlcltyeFN1YnNjcmliZXJdKCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFuZXh0T3JPYnNlcnZlciAmJiAhZXJyb3IgJiYgIWNvbXBsZXRlKSB7XG4gICAgcmV0dXJuIG5ldyBTdWJzY3JpYmVyKGVtcHR5KTtcbiAgfVxuXG4gIHJldHVybiBuZXcgU3Vic2NyaWJlcihuZXh0T3JPYnNlcnZlciwgZXJyb3IsIGNvbXBsZXRlKTtcbn1cbi8qKiBQVVJFX0lNUE9SVFNfU1RBUlQgIFBVUkVfSU1QT1JUU19FTkQgKi9cblxuXG52YXIgb2JzZXJ2YWJsZSA9IC8qQF9fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5vYnNlcnZhYmxlIHx8ICdAQG9ic2VydmFibGUnO1xufSgpO1xuLyoqIFBVUkVfSU1QT1JUU19TVEFSVCAgUFVSRV9JTVBPUlRTX0VORCAqL1xuXG5cbmZ1bmN0aW9uIGlkZW50aXR5KHgpIHtcbiAgcmV0dXJuIHg7XG59XG4vKiogUFVSRV9JTVBPUlRTX1NUQVJUIF9pZGVudGl0eSBQVVJFX0lNUE9SVFNfRU5EICovXG5cblxuZnVuY3Rpb24gcGlwZUZyb21BcnJheShmbnMpIHtcbiAgaWYgKGZucy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gaWRlbnRpdHk7XG4gIH1cblxuICBpZiAoZm5zLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiBmbnNbMF07XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gcGlwZWQoaW5wdXQpIHtcbiAgICByZXR1cm4gZm5zLnJlZHVjZShmdW5jdGlvbiAocHJldiwgZm4pIHtcbiAgICAgIHJldHVybiBmbihwcmV2KTtcbiAgICB9LCBpbnB1dCk7XG4gIH07XG59XG4vKiogUFVSRV9JTVBPUlRTX1NUQVJUIF91dGlsX2NhblJlcG9ydEVycm9yLF91dGlsX3RvU3Vic2NyaWJlcixfc3ltYm9sX29ic2VydmFibGUsX3V0aWxfcGlwZSxfY29uZmlnIFBVUkVfSU1QT1JUU19FTkQgKi9cblxuXG52YXIgT2JzZXJ2YWJsZSA9IC8qQF9fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIE9ic2VydmFibGUoc3Vic2NyaWJlKSB7XG4gICAgdGhpcy5faXNTY2FsYXIgPSBmYWxzZTtcblxuICAgIGlmIChzdWJzY3JpYmUpIHtcbiAgICAgIHRoaXMuX3N1YnNjcmliZSA9IHN1YnNjcmliZTtcbiAgICB9XG4gIH1cblxuICBPYnNlcnZhYmxlLnByb3RvdHlwZS5saWZ0ID0gZnVuY3Rpb24gKG9wZXJhdG9yKSB7XG4gICAgdmFyIG9ic2VydmFibGUgPSBuZXcgT2JzZXJ2YWJsZSgpO1xuICAgIG9ic2VydmFibGUuc291cmNlID0gdGhpcztcbiAgICBvYnNlcnZhYmxlLm9wZXJhdG9yID0gb3BlcmF0b3I7XG4gICAgcmV0dXJuIG9ic2VydmFibGU7XG4gIH07XG5cbiAgT2JzZXJ2YWJsZS5wcm90b3R5cGUuc3Vic2NyaWJlID0gZnVuY3Rpb24gKG9ic2VydmVyT3JOZXh0LCBlcnJvciwgY29tcGxldGUpIHtcbiAgICB2YXIgb3BlcmF0b3IgPSB0aGlzLm9wZXJhdG9yO1xuICAgIHZhciBzaW5rID0gdG9TdWJzY3JpYmVyKG9ic2VydmVyT3JOZXh0LCBlcnJvciwgY29tcGxldGUpO1xuXG4gICAgaWYgKG9wZXJhdG9yKSB7XG4gICAgICBzaW5rLmFkZChvcGVyYXRvci5jYWxsKHNpbmssIHRoaXMuc291cmNlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNpbmsuYWRkKHRoaXMuc291cmNlIHx8IGNvbmZpZy51c2VEZXByZWNhdGVkU3luY2hyb25vdXNFcnJvckhhbmRsaW5nICYmICFzaW5rLnN5bmNFcnJvclRocm93YWJsZSA/IHRoaXMuX3N1YnNjcmliZShzaW5rKSA6IHRoaXMuX3RyeVN1YnNjcmliZShzaW5rKSk7XG4gICAgfVxuXG4gICAgaWYgKGNvbmZpZy51c2VEZXByZWNhdGVkU3luY2hyb25vdXNFcnJvckhhbmRsaW5nKSB7XG4gICAgICBpZiAoc2luay5zeW5jRXJyb3JUaHJvd2FibGUpIHtcbiAgICAgICAgc2luay5zeW5jRXJyb3JUaHJvd2FibGUgPSBmYWxzZTtcblxuICAgICAgICBpZiAoc2luay5zeW5jRXJyb3JUaHJvd24pIHtcbiAgICAgICAgICB0aHJvdyBzaW5rLnN5bmNFcnJvclZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHNpbms7XG4gIH07XG5cbiAgT2JzZXJ2YWJsZS5wcm90b3R5cGUuX3RyeVN1YnNjcmliZSA9IGZ1bmN0aW9uIChzaW5rKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB0aGlzLl9zdWJzY3JpYmUoc2luayk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBpZiAoY29uZmlnLnVzZURlcHJlY2F0ZWRTeW5jaHJvbm91c0Vycm9ySGFuZGxpbmcpIHtcbiAgICAgICAgc2luay5zeW5jRXJyb3JUaHJvd24gPSB0cnVlO1xuICAgICAgICBzaW5rLnN5bmNFcnJvclZhbHVlID0gZXJyO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2FuUmVwb3J0RXJyb3Ioc2luaykpIHtcbiAgICAgICAgc2luay5lcnJvcihlcnIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS53YXJuKGVycik7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIE9ic2VydmFibGUucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiAobmV4dCwgcHJvbWlzZUN0b3IpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgcHJvbWlzZUN0b3IgPSBnZXRQcm9taXNlQ3Rvcihwcm9taXNlQ3Rvcik7XG4gICAgcmV0dXJuIG5ldyBwcm9taXNlQ3RvcihmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgc3Vic2NyaXB0aW9uO1xuICAgICAgc3Vic2NyaXB0aW9uID0gX3RoaXMuc3Vic2NyaWJlKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIG5leHQodmFsdWUpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICByZWplY3QoZXJyKTtcblxuICAgICAgICAgIGlmIChzdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwgcmVqZWN0LCByZXNvbHZlKTtcbiAgICB9KTtcbiAgfTtcblxuICBPYnNlcnZhYmxlLnByb3RvdHlwZS5fc3Vic2NyaWJlID0gZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcbiAgICB2YXIgc291cmNlID0gdGhpcy5zb3VyY2U7XG4gICAgcmV0dXJuIHNvdXJjZSAmJiBzb3VyY2Uuc3Vic2NyaWJlKHN1YnNjcmliZXIpO1xuICB9O1xuXG4gIE9ic2VydmFibGUucHJvdG90eXBlW29ic2VydmFibGVdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIE9ic2VydmFibGUucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG9wZXJhdGlvbnMgPSBbXTtcblxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICBvcGVyYXRpb25zW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuXG4gICAgaWYgKG9wZXJhdGlvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICByZXR1cm4gcGlwZUZyb21BcnJheShvcGVyYXRpb25zKSh0aGlzKTtcbiAgfTtcblxuICBPYnNlcnZhYmxlLnByb3RvdHlwZS50b1Byb21pc2UgPSBmdW5jdGlvbiAocHJvbWlzZUN0b3IpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgcHJvbWlzZUN0b3IgPSBnZXRQcm9taXNlQ3Rvcihwcm9taXNlQ3Rvcik7XG4gICAgcmV0dXJuIG5ldyBwcm9taXNlQ3RvcihmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgdmFsdWU7XG5cbiAgICAgIF90aGlzLnN1YnNjcmliZShmdW5jdGlvbiAoeCkge1xuICAgICAgICByZXR1cm4gdmFsdWUgPSB4O1xuICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICByZXR1cm4gcmVqZWN0KGVycik7XG4gICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiByZXNvbHZlKHZhbHVlKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIE9ic2VydmFibGUuY3JlYXRlID0gZnVuY3Rpb24gKHN1YnNjcmliZSkge1xuICAgIHJldHVybiBuZXcgT2JzZXJ2YWJsZShzdWJzY3JpYmUpO1xuICB9O1xuXG4gIHJldHVybiBPYnNlcnZhYmxlO1xufSgpO1xuXG5mdW5jdGlvbiBnZXRQcm9taXNlQ3Rvcihwcm9taXNlQ3Rvcikge1xuICBpZiAoIXByb21pc2VDdG9yKSB7XG4gICAgcHJvbWlzZUN0b3IgPSBQcm9taXNlO1xuICB9XG5cbiAgaWYgKCFwcm9taXNlQ3Rvcikge1xuICAgIHRocm93IG5ldyBFcnJvcignbm8gUHJvbWlzZSBpbXBsIGZvdW5kJyk7XG4gIH1cblxuICByZXR1cm4gcHJvbWlzZUN0b3I7XG59XG4vKiogUFVSRV9JTVBPUlRTX1NUQVJUICBQVVJFX0lNUE9SVFNfRU5EICovXG5cblxudmFyIHN1YnNjcmliZVRvQXJyYXkgPSBmdW5jdGlvbiAoYXJyYXkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbiAmJiAhc3Vic2NyaWJlci5jbG9zZWQ7IGkrKykge1xuICAgICAgc3Vic2NyaWJlci5uZXh0KGFycmF5W2ldKTtcbiAgICB9XG5cbiAgICBzdWJzY3JpYmVyLmNvbXBsZXRlKCk7XG4gIH07XG59O1xuLyoqIFBVUkVfSU1QT1JUU19TVEFSVCBfaG9zdFJlcG9ydEVycm9yIFBVUkVfSU1QT1JUU19FTkQgKi9cblxuXG52YXIgc3Vic2NyaWJlVG9Qcm9taXNlID0gZnVuY3Rpb24gKHByb21pc2UpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XG4gICAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgaWYgKCFzdWJzY3JpYmVyLmNsb3NlZCkge1xuICAgICAgICBzdWJzY3JpYmVyLm5leHQodmFsdWUpO1xuICAgICAgICBzdWJzY3JpYmVyLmNvbXBsZXRlKCk7XG4gICAgICB9XG4gICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgcmV0dXJuIHN1YnNjcmliZXIuZXJyb3IoZXJyKTtcbiAgICB9KS50aGVuKG51bGwsIGhvc3RSZXBvcnRFcnJvcik7XG4gICAgcmV0dXJuIHN1YnNjcmliZXI7XG4gIH07XG59O1xuLyoqIFBVUkVfSU1QT1JUU19TVEFSVCAgUFVSRV9JTVBPUlRTX0VORCAqL1xuXG5cbmZ1bmN0aW9uIGdldFN5bWJvbEl0ZXJhdG9yKCkge1xuICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gJ2Z1bmN0aW9uJyB8fCAhU3ltYm9sLml0ZXJhdG9yKSB7XG4gICAgcmV0dXJuICdAQGl0ZXJhdG9yJztcbiAgfVxuXG4gIHJldHVybiBTeW1ib2wuaXRlcmF0b3I7XG59XG5cbnZhciBpdGVyYXRvciA9IC8qQF9fUFVSRV9fKi9nZXRTeW1ib2xJdGVyYXRvcigpO1xuLyoqIFBVUkVfSU1QT1JUU19TVEFSVCBfc3ltYm9sX2l0ZXJhdG9yIFBVUkVfSU1QT1JUU19FTkQgKi9cblxudmFyIHN1YnNjcmliZVRvSXRlcmFibGUgPSBmdW5jdGlvbiAoaXRlcmFibGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XG4gICAgdmFyIGl0ZXJhdG9yJDEgPSBpdGVyYWJsZVtpdGVyYXRvcl0oKTtcblxuICAgIGRvIHtcbiAgICAgIHZhciBpdGVtID0gdm9pZCAwO1xuXG4gICAgICB0cnkge1xuICAgICAgICBpdGVtID0gaXRlcmF0b3IkMS5uZXh0KCk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgc3Vic2NyaWJlci5lcnJvcihlcnIpO1xuICAgICAgICByZXR1cm4gc3Vic2NyaWJlcjtcbiAgICAgIH1cblxuICAgICAgaWYgKGl0ZW0uZG9uZSkge1xuICAgICAgICBzdWJzY3JpYmVyLmNvbXBsZXRlKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBzdWJzY3JpYmVyLm5leHQoaXRlbS52YWx1ZSk7XG5cbiAgICAgIGlmIChzdWJzY3JpYmVyLmNsb3NlZCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IHdoaWxlICh0cnVlKTtcblxuICAgIGlmICh0eXBlb2YgaXRlcmF0b3IkMS5yZXR1cm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHN1YnNjcmliZXIuYWRkKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGl0ZXJhdG9yJDEucmV0dXJuKSB7XG4gICAgICAgICAgaXRlcmF0b3IkMS5yZXR1cm4oKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN1YnNjcmliZXI7XG4gIH07XG59O1xuLyoqIFBVUkVfSU1QT1JUU19TVEFSVCBfc3ltYm9sX29ic2VydmFibGUgUFVSRV9JTVBPUlRTX0VORCAqL1xuXG5cbnZhciBzdWJzY3JpYmVUb09ic2VydmFibGUgPSBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoc3Vic2NyaWJlcikge1xuICAgIHZhciBvYnMgPSBvYmpbb2JzZXJ2YWJsZV0oKTtcblxuICAgIGlmICh0eXBlb2Ygb2JzLnN1YnNjcmliZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUHJvdmlkZWQgb2JqZWN0IGRvZXMgbm90IGNvcnJlY3RseSBpbXBsZW1lbnQgU3ltYm9sLm9ic2VydmFibGUnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG9icy5zdWJzY3JpYmUoc3Vic2NyaWJlcik7XG4gICAgfVxuICB9O1xufTtcbi8qKiBQVVJFX0lNUE9SVFNfU1RBUlQgIFBVUkVfSU1QT1JUU19FTkQgKi9cblxuXG52YXIgaXNBcnJheUxpa2UgPSBmdW5jdGlvbiAoeCkge1xuICByZXR1cm4geCAmJiB0eXBlb2YgeC5sZW5ndGggPT09ICdudW1iZXInICYmIHR5cGVvZiB4ICE9PSAnZnVuY3Rpb24nO1xufTtcbi8qKiBQVVJFX0lNUE9SVFNfU1RBUlQgIFBVUkVfSU1QT1JUU19FTkQgKi9cblxuXG5mdW5jdGlvbiBpc1Byb21pc2UodmFsdWUpIHtcbiAgcmV0dXJuICEhdmFsdWUgJiYgdHlwZW9mIHZhbHVlLnN1YnNjcmliZSAhPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsdWUudGhlbiA9PT0gJ2Z1bmN0aW9uJztcbn1cbi8qKiBQVVJFX0lNUE9SVFNfU1RBUlQgX3N1YnNjcmliZVRvQXJyYXksX3N1YnNjcmliZVRvUHJvbWlzZSxfc3Vic2NyaWJlVG9JdGVyYWJsZSxfc3Vic2NyaWJlVG9PYnNlcnZhYmxlLF9pc0FycmF5TGlrZSxfaXNQcm9taXNlLF9pc09iamVjdCxfc3ltYm9sX2l0ZXJhdG9yLF9zeW1ib2xfb2JzZXJ2YWJsZSBQVVJFX0lNUE9SVFNfRU5EICovXG5cblxudmFyIHN1YnNjcmliZVRvID0gZnVuY3Rpb24gKHJlc3VsdCkge1xuICBpZiAoISFyZXN1bHQgJiYgdHlwZW9mIHJlc3VsdFtvYnNlcnZhYmxlXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBzdWJzY3JpYmVUb09ic2VydmFibGUocmVzdWx0KTtcbiAgfSBlbHNlIGlmIChpc0FycmF5TGlrZShyZXN1bHQpKSB7XG4gICAgcmV0dXJuIHN1YnNjcmliZVRvQXJyYXkocmVzdWx0KTtcbiAgfSBlbHNlIGlmIChpc1Byb21pc2UocmVzdWx0KSkge1xuICAgIHJldHVybiBzdWJzY3JpYmVUb1Byb21pc2UocmVzdWx0KTtcbiAgfSBlbHNlIGlmICghIXJlc3VsdCAmJiB0eXBlb2YgcmVzdWx0W2l0ZXJhdG9yXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBzdWJzY3JpYmVUb0l0ZXJhYmxlKHJlc3VsdCk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHZhbHVlID0gaXNPYmplY3QocmVzdWx0KSA/ICdhbiBpbnZhbGlkIG9iamVjdCcgOiBcIidcIiArIHJlc3VsdCArIFwiJ1wiO1xuICAgIHZhciBtc2cgPSBcIllvdSBwcm92aWRlZCBcIiArIHZhbHVlICsgXCIgd2hlcmUgYSBzdHJlYW0gd2FzIGV4cGVjdGVkLlwiICsgJyBZb3UgY2FuIHByb3ZpZGUgYW4gT2JzZXJ2YWJsZSwgUHJvbWlzZSwgQXJyYXksIG9yIEl0ZXJhYmxlLic7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihtc2cpO1xuICB9XG59O1xuLyoqIFBVUkVfSU1QT1JUU19TVEFSVCB0c2xpYixfU3Vic2NyaWJlcixfT2JzZXJ2YWJsZSxfdXRpbF9zdWJzY3JpYmVUbyBQVVJFX0lNUE9SVFNfRU5EICovXG5cblxudmFyIFNpbXBsZUlubmVyU3Vic2NyaWJlciA9IC8qQF9fUFVSRV9fKi9mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhTaW1wbGVJbm5lclN1YnNjcmliZXIsIF9zdXBlcik7XG5cbiAgZnVuY3Rpb24gU2ltcGxlSW5uZXJTdWJzY3JpYmVyKHBhcmVudCkge1xuICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG5cbiAgICBfdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgU2ltcGxlSW5uZXJTdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHRoaXMucGFyZW50Lm5vdGlmeU5leHQodmFsdWUpO1xuICB9O1xuXG4gIFNpbXBsZUlubmVyU3Vic2NyaWJlci5wcm90b3R5cGUuX2Vycm9yID0gZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgdGhpcy5wYXJlbnQubm90aWZ5RXJyb3IoZXJyb3IpO1xuICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgfTtcblxuICBTaW1wbGVJbm5lclN1YnNjcmliZXIucHJvdG90eXBlLl9jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnBhcmVudC5ub3RpZnlDb21wbGV0ZSgpO1xuICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgfTtcblxuICByZXR1cm4gU2ltcGxlSW5uZXJTdWJzY3JpYmVyO1xufShTdWJzY3JpYmVyKTtcblxudmFyIFNpbXBsZU91dGVyU3Vic2NyaWJlciA9IC8qQF9fUFVSRV9fKi9mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhTaW1wbGVPdXRlclN1YnNjcmliZXIsIF9zdXBlcik7XG5cbiAgZnVuY3Rpb24gU2ltcGxlT3V0ZXJTdWJzY3JpYmVyKCkge1xuICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgfVxuXG4gIFNpbXBsZU91dGVyU3Vic2NyaWJlci5wcm90b3R5cGUubm90aWZ5TmV4dCA9IGZ1bmN0aW9uIChpbm5lclZhbHVlKSB7XG4gICAgdGhpcy5kZXN0aW5hdGlvbi5uZXh0KGlubmVyVmFsdWUpO1xuICB9O1xuXG4gIFNpbXBsZU91dGVyU3Vic2NyaWJlci5wcm90b3R5cGUubm90aWZ5RXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgdGhpcy5kZXN0aW5hdGlvbi5lcnJvcihlcnIpO1xuICB9O1xuXG4gIFNpbXBsZU91dGVyU3Vic2NyaWJlci5wcm90b3R5cGUubm90aWZ5Q29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5kZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICB9O1xuXG4gIHJldHVybiBTaW1wbGVPdXRlclN1YnNjcmliZXI7XG59KFN1YnNjcmliZXIpO1xuXG5mdW5jdGlvbiBpbm5lclN1YnNjcmliZShyZXN1bHQsIGlubmVyU3Vic2NyaWJlcikge1xuICBpZiAoaW5uZXJTdWJzY3JpYmVyLmNsb3NlZCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICBpZiAocmVzdWx0IGluc3RhbmNlb2YgT2JzZXJ2YWJsZSkge1xuICAgIHJldHVybiByZXN1bHQuc3Vic2NyaWJlKGlubmVyU3Vic2NyaWJlcik7XG4gIH1cblxuICByZXR1cm4gc3Vic2NyaWJlVG8ocmVzdWx0KShpbm5lclN1YnNjcmliZXIpO1xufVxuLyoqIFBVUkVfSU1QT1JUU19TVEFSVCB0c2xpYixfU3Vic2NyaXB0aW9uIFBVUkVfSU1QT1JUU19FTkQgKi9cblxuXG52YXIgQWN0aW9uID0gLypAX19QVVJFX18qL2Z1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKEFjdGlvbiwgX3N1cGVyKTtcblxuICBmdW5jdGlvbiBBY3Rpb24oc2NoZWR1bGVyLCB3b3JrKSB7XG4gICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gIH1cblxuICBBY3Rpb24ucHJvdG90eXBlLnNjaGVkdWxlID0gZnVuY3Rpb24gKHN0YXRlLCBkZWxheSkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIHJldHVybiBBY3Rpb247XG59KFN1YnNjcmlwdGlvbik7XG4vKiogUFVSRV9JTVBPUlRTX1NUQVJUIHRzbGliLF9BY3Rpb24gUFVSRV9JTVBPUlRTX0VORCAqL1xuXG5cbnZhciBBc3luY0FjdGlvbiA9IC8qQF9fUFVSRV9fKi9mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhBc3luY0FjdGlvbiwgX3N1cGVyKTtcblxuICBmdW5jdGlvbiBBc3luY0FjdGlvbihzY2hlZHVsZXIsIHdvcmspIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBzY2hlZHVsZXIsIHdvcmspIHx8IHRoaXM7XG5cbiAgICBfdGhpcy5zY2hlZHVsZXIgPSBzY2hlZHVsZXI7XG4gICAgX3RoaXMud29yayA9IHdvcms7XG4gICAgX3RoaXMucGVuZGluZyA9IGZhbHNlO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIEFzeW5jQWN0aW9uLnByb3RvdHlwZS5zY2hlZHVsZSA9IGZ1bmN0aW9uIChzdGF0ZSwgZGVsYXkpIHtcbiAgICBpZiAoZGVsYXkgPT09IHZvaWQgMCkge1xuICAgICAgZGVsYXkgPSAwO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmNsb3NlZCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgIHZhciBpZCA9IHRoaXMuaWQ7XG4gICAgdmFyIHNjaGVkdWxlciA9IHRoaXMuc2NoZWR1bGVyO1xuXG4gICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgIHRoaXMuaWQgPSB0aGlzLnJlY3ljbGVBc3luY0lkKHNjaGVkdWxlciwgaWQsIGRlbGF5KTtcbiAgICB9XG5cbiAgICB0aGlzLnBlbmRpbmcgPSB0cnVlO1xuICAgIHRoaXMuZGVsYXkgPSBkZWxheTtcbiAgICB0aGlzLmlkID0gdGhpcy5pZCB8fCB0aGlzLnJlcXVlc3RBc3luY0lkKHNjaGVkdWxlciwgdGhpcy5pZCwgZGVsYXkpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEFzeW5jQWN0aW9uLnByb3RvdHlwZS5yZXF1ZXN0QXN5bmNJZCA9IGZ1bmN0aW9uIChzY2hlZHVsZXIsIGlkLCBkZWxheSkge1xuICAgIGlmIChkZWxheSA9PT0gdm9pZCAwKSB7XG4gICAgICBkZWxheSA9IDA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNldEludGVydmFsKHNjaGVkdWxlci5mbHVzaC5iaW5kKHNjaGVkdWxlciwgdGhpcyksIGRlbGF5KTtcbiAgfTtcblxuICBBc3luY0FjdGlvbi5wcm90b3R5cGUucmVjeWNsZUFzeW5jSWQgPSBmdW5jdGlvbiAoc2NoZWR1bGVyLCBpZCwgZGVsYXkpIHtcbiAgICBpZiAoZGVsYXkgPT09IHZvaWQgMCkge1xuICAgICAgZGVsYXkgPSAwO1xuICAgIH1cblxuICAgIGlmIChkZWxheSAhPT0gbnVsbCAmJiB0aGlzLmRlbGF5ID09PSBkZWxheSAmJiB0aGlzLnBlbmRpbmcgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm4gaWQ7XG4gICAgfVxuXG4gICAgY2xlYXJJbnRlcnZhbChpZCk7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfTtcblxuICBBc3luY0FjdGlvbi5wcm90b3R5cGUuZXhlY3V0ZSA9IGZ1bmN0aW9uIChzdGF0ZSwgZGVsYXkpIHtcbiAgICBpZiAodGhpcy5jbG9zZWQpIHtcbiAgICAgIHJldHVybiBuZXcgRXJyb3IoJ2V4ZWN1dGluZyBhIGNhbmNlbGxlZCBhY3Rpb24nKTtcbiAgICB9XG5cbiAgICB0aGlzLnBlbmRpbmcgPSBmYWxzZTtcblxuICAgIHZhciBlcnJvciA9IHRoaXMuX2V4ZWN1dGUoc3RhdGUsIGRlbGF5KTtcblxuICAgIGlmIChlcnJvcikge1xuICAgICAgcmV0dXJuIGVycm9yO1xuICAgIH0gZWxzZSBpZiAodGhpcy5wZW5kaW5nID09PSBmYWxzZSAmJiB0aGlzLmlkICE9IG51bGwpIHtcbiAgICAgIHRoaXMuaWQgPSB0aGlzLnJlY3ljbGVBc3luY0lkKHRoaXMuc2NoZWR1bGVyLCB0aGlzLmlkLCBudWxsKTtcbiAgICB9XG4gIH07XG5cbiAgQXN5bmNBY3Rpb24ucHJvdG90eXBlLl9leGVjdXRlID0gZnVuY3Rpb24gKHN0YXRlLCBkZWxheSkge1xuICAgIHZhciBlcnJvcmVkID0gZmFsc2U7XG4gICAgdmFyIGVycm9yVmFsdWUgPSB1bmRlZmluZWQ7XG5cbiAgICB0cnkge1xuICAgICAgdGhpcy53b3JrKHN0YXRlKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBlcnJvcmVkID0gdHJ1ZTtcbiAgICAgIGVycm9yVmFsdWUgPSAhIWUgJiYgZSB8fCBuZXcgRXJyb3IoZSk7XG4gICAgfVxuXG4gICAgaWYgKGVycm9yZWQpIHtcbiAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICAgIHJldHVybiBlcnJvclZhbHVlO1xuICAgIH1cbiAgfTtcblxuICBBc3luY0FjdGlvbi5wcm90b3R5cGUuX3Vuc3Vic2NyaWJlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBpZCA9IHRoaXMuaWQ7XG4gICAgdmFyIHNjaGVkdWxlciA9IHRoaXMuc2NoZWR1bGVyO1xuICAgIHZhciBhY3Rpb25zID0gc2NoZWR1bGVyLmFjdGlvbnM7XG4gICAgdmFyIGluZGV4ID0gYWN0aW9ucy5pbmRleE9mKHRoaXMpO1xuICAgIHRoaXMud29yayA9IG51bGw7XG4gICAgdGhpcy5zdGF0ZSA9IG51bGw7XG4gICAgdGhpcy5wZW5kaW5nID0gZmFsc2U7XG4gICAgdGhpcy5zY2hlZHVsZXIgPSBudWxsO1xuXG4gICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgYWN0aW9ucy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIH1cblxuICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICB0aGlzLmlkID0gdGhpcy5yZWN5Y2xlQXN5bmNJZChzY2hlZHVsZXIsIGlkLCBudWxsKTtcbiAgICB9XG5cbiAgICB0aGlzLmRlbGF5ID0gbnVsbDtcbiAgfTtcblxuICByZXR1cm4gQXN5bmNBY3Rpb247XG59KEFjdGlvbik7XG5cbnZhciBTY2hlZHVsZXIgPSAvKkBfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBTY2hlZHVsZXIoU2NoZWR1bGVyQWN0aW9uLCBub3cpIHtcbiAgICBpZiAobm93ID09PSB2b2lkIDApIHtcbiAgICAgIG5vdyA9IFNjaGVkdWxlci5ub3c7XG4gICAgfVxuXG4gICAgdGhpcy5TY2hlZHVsZXJBY3Rpb24gPSBTY2hlZHVsZXJBY3Rpb247XG4gICAgdGhpcy5ub3cgPSBub3c7XG4gIH1cblxuICBTY2hlZHVsZXIucHJvdG90eXBlLnNjaGVkdWxlID0gZnVuY3Rpb24gKHdvcmssIGRlbGF5LCBzdGF0ZSkge1xuICAgIGlmIChkZWxheSA9PT0gdm9pZCAwKSB7XG4gICAgICBkZWxheSA9IDA7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyB0aGlzLlNjaGVkdWxlckFjdGlvbih0aGlzLCB3b3JrKS5zY2hlZHVsZShzdGF0ZSwgZGVsYXkpO1xuICB9O1xuXG4gIFNjaGVkdWxlci5ub3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIERhdGUubm93KCk7XG4gIH07XG5cbiAgcmV0dXJuIFNjaGVkdWxlcjtcbn0oKTtcbi8qKiBQVVJFX0lNUE9SVFNfU1RBUlQgdHNsaWIsX1NjaGVkdWxlciBQVVJFX0lNUE9SVFNfRU5EICovXG5cblxudmFyIEFzeW5jU2NoZWR1bGVyID0gLypAX19QVVJFX18qL2Z1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKEFzeW5jU2NoZWR1bGVyLCBfc3VwZXIpO1xuXG4gIGZ1bmN0aW9uIEFzeW5jU2NoZWR1bGVyKFNjaGVkdWxlckFjdGlvbiwgbm93KSB7XG4gICAgaWYgKG5vdyA9PT0gdm9pZCAwKSB7XG4gICAgICBub3cgPSBTY2hlZHVsZXIubm93O1xuICAgIH1cblxuICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIFNjaGVkdWxlckFjdGlvbiwgZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKEFzeW5jU2NoZWR1bGVyLmRlbGVnYXRlICYmIEFzeW5jU2NoZWR1bGVyLmRlbGVnYXRlICE9PSBfdGhpcykge1xuICAgICAgICByZXR1cm4gQXN5bmNTY2hlZHVsZXIuZGVsZWdhdGUubm93KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbm93KCk7XG4gICAgICB9XG4gICAgfSkgfHwgdGhpcztcblxuICAgIF90aGlzLmFjdGlvbnMgPSBbXTtcbiAgICBfdGhpcy5hY3RpdmUgPSBmYWxzZTtcbiAgICBfdGhpcy5zY2hlZHVsZWQgPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgQXN5bmNTY2hlZHVsZXIucHJvdG90eXBlLnNjaGVkdWxlID0gZnVuY3Rpb24gKHdvcmssIGRlbGF5LCBzdGF0ZSkge1xuICAgIGlmIChkZWxheSA9PT0gdm9pZCAwKSB7XG4gICAgICBkZWxheSA9IDA7XG4gICAgfVxuXG4gICAgaWYgKEFzeW5jU2NoZWR1bGVyLmRlbGVnYXRlICYmIEFzeW5jU2NoZWR1bGVyLmRlbGVnYXRlICE9PSB0aGlzKSB7XG4gICAgICByZXR1cm4gQXN5bmNTY2hlZHVsZXIuZGVsZWdhdGUuc2NoZWR1bGUod29yaywgZGVsYXksIHN0YXRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUuc2NoZWR1bGUuY2FsbCh0aGlzLCB3b3JrLCBkZWxheSwgc3RhdGUpO1xuICAgIH1cbiAgfTtcblxuICBBc3luY1NjaGVkdWxlci5wcm90b3R5cGUuZmx1c2ggPSBmdW5jdGlvbiAoYWN0aW9uKSB7XG4gICAgdmFyIGFjdGlvbnMgPSB0aGlzLmFjdGlvbnM7XG5cbiAgICBpZiAodGhpcy5hY3RpdmUpIHtcbiAgICAgIGFjdGlvbnMucHVzaChhY3Rpb24pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBlcnJvcjtcbiAgICB0aGlzLmFjdGl2ZSA9IHRydWU7XG5cbiAgICBkbyB7XG4gICAgICBpZiAoZXJyb3IgPSBhY3Rpb24uZXhlY3V0ZShhY3Rpb24uc3RhdGUsIGFjdGlvbi5kZWxheSkpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSB3aGlsZSAoYWN0aW9uID0gYWN0aW9ucy5zaGlmdCgpKTtcblxuICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XG5cbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIHdoaWxlIChhY3Rpb24gPSBhY3Rpb25zLnNoaWZ0KCkpIHtcbiAgICAgICAgYWN0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICB9XG5cbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gQXN5bmNTY2hlZHVsZXI7XG59KFNjaGVkdWxlcik7XG4vKiogUFVSRV9JTVBPUlRTX1NUQVJUIF9Bc3luY0FjdGlvbixfQXN5bmNTY2hlZHVsZXIgUFVSRV9JTVBPUlRTX0VORCAqL1xuXG5cbnZhciBhc3luY1NjaGVkdWxlciA9IC8qQF9fUFVSRV9fKi9uZXcgQXN5bmNTY2hlZHVsZXIoQXN5bmNBY3Rpb24pO1xudmFyIGFzeW5jID0gYXN5bmNTY2hlZHVsZXI7XG4vKiogUFVSRV9JTVBPUlRTX1NUQVJUICBQVVJFX0lNUE9SVFNfRU5EICovXG5cbmZ1bmN0aW9uIGlzRGF0ZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBEYXRlICYmICFpc05hTigrdmFsdWUpO1xufVxuLyoqIFBVUkVfSU1QT1JUU19TVEFSVCBfT2JzZXJ2YWJsZSBQVVJFX0lNUE9SVFNfRU5EICovXG5cblxudmFyIEVNUFRZID0gLypAX19QVVJFX18qL25ldyBPYnNlcnZhYmxlKGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XG4gIHJldHVybiBzdWJzY3JpYmVyLmNvbXBsZXRlKCk7XG59KTtcblxuZnVuY3Rpb24gZW1wdHkkMShzY2hlZHVsZXIpIHtcbiAgcmV0dXJuIHNjaGVkdWxlciA/IGVtcHR5U2NoZWR1bGVkKHNjaGVkdWxlcikgOiBFTVBUWTtcbn1cblxuZnVuY3Rpb24gZW1wdHlTY2hlZHVsZWQoc2NoZWR1bGVyKSB7XG4gIHJldHVybiBuZXcgT2JzZXJ2YWJsZShmdW5jdGlvbiAoc3Vic2NyaWJlcikge1xuICAgIHJldHVybiBzY2hlZHVsZXIuc2NoZWR1bGUoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHN1YnNjcmliZXIuY29tcGxldGUoKTtcbiAgICB9KTtcbiAgfSk7XG59XG4vKiogUFVSRV9JTVBPUlRTX1NUQVJUIF9PYnNlcnZhYmxlIFBVUkVfSU1QT1JUU19FTkQgKi9cblxuXG5mdW5jdGlvbiB0aHJvd0Vycm9yKGVycm9yLCBzY2hlZHVsZXIpIHtcbiAgaWYgKCFzY2hlZHVsZXIpIHtcbiAgICByZXR1cm4gbmV3IE9ic2VydmFibGUoZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcbiAgICAgIHJldHVybiBzdWJzY3JpYmVyLmVycm9yKGVycm9yKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3IE9ic2VydmFibGUoZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcbiAgICAgIHJldHVybiBzY2hlZHVsZXIuc2NoZWR1bGUoZGlzcGF0Y2gsIDAsIHtcbiAgICAgICAgZXJyb3I6IGVycm9yLFxuICAgICAgICBzdWJzY3JpYmVyOiBzdWJzY3JpYmVyXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkaXNwYXRjaChfYSkge1xuICB2YXIgZXJyb3IgPSBfYS5lcnJvcixcbiAgICAgIHN1YnNjcmliZXIgPSBfYS5zdWJzY3JpYmVyO1xuICBzdWJzY3JpYmVyLmVycm9yKGVycm9yKTtcbn1cbi8qKiBQVVJFX0lNUE9SVFNfU1RBUlQgIFBVUkVfSU1QT1JUU19FTkQgKi9cblxuXG52YXIgQXJndW1lbnRPdXRPZlJhbmdlRXJyb3JJbXBsID0gLypAX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQXJndW1lbnRPdXRPZlJhbmdlRXJyb3JJbXBsKCkge1xuICAgIEVycm9yLmNhbGwodGhpcyk7XG4gICAgdGhpcy5tZXNzYWdlID0gJ2FyZ3VtZW50IG91dCBvZiByYW5nZSc7XG4gICAgdGhpcy5uYW1lID0gJ0FyZ3VtZW50T3V0T2ZSYW5nZUVycm9yJztcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIEFyZ3VtZW50T3V0T2ZSYW5nZUVycm9ySW1wbC5wcm90b3R5cGUgPSAvKkBfX1BVUkVfXyovT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUpO1xuICByZXR1cm4gQXJndW1lbnRPdXRPZlJhbmdlRXJyb3JJbXBsO1xufSgpO1xuXG52YXIgQXJndW1lbnRPdXRPZlJhbmdlRXJyb3IgPSBBcmd1bWVudE91dE9mUmFuZ2VFcnJvckltcGw7XG4vKiogUFVSRV9JTVBPUlRTX1NUQVJUIHRzbGliLF9TdWJzY3JpYmVyIFBVUkVfSU1QT1JUU19FTkQgKi9cblxuZnVuY3Rpb24gZmlsdGVyKHByZWRpY2F0ZSwgdGhpc0FyZykge1xuICByZXR1cm4gZnVuY3Rpb24gZmlsdGVyT3BlcmF0b3JGdW5jdGlvbihzb3VyY2UpIHtcbiAgICByZXR1cm4gc291cmNlLmxpZnQobmV3IEZpbHRlck9wZXJhdG9yKHByZWRpY2F0ZSwgdGhpc0FyZykpO1xuICB9O1xufVxuXG52YXIgRmlsdGVyT3BlcmF0b3IgPSAvKkBfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBGaWx0ZXJPcGVyYXRvcihwcmVkaWNhdGUsIHRoaXNBcmcpIHtcbiAgICB0aGlzLnByZWRpY2F0ZSA9IHByZWRpY2F0ZTtcbiAgICB0aGlzLnRoaXNBcmcgPSB0aGlzQXJnO1xuICB9XG5cbiAgRmlsdGVyT3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoc3Vic2NyaWJlciwgc291cmNlKSB7XG4gICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IEZpbHRlclN1YnNjcmliZXIoc3Vic2NyaWJlciwgdGhpcy5wcmVkaWNhdGUsIHRoaXMudGhpc0FyZykpO1xuICB9O1xuXG4gIHJldHVybiBGaWx0ZXJPcGVyYXRvcjtcbn0oKTtcblxudmFyIEZpbHRlclN1YnNjcmliZXIgPSAvKkBfX1BVUkVfXyovZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoRmlsdGVyU3Vic2NyaWJlciwgX3N1cGVyKTtcblxuICBmdW5jdGlvbiBGaWx0ZXJTdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCBwcmVkaWNhdGUsIHRoaXNBcmcpIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbikgfHwgdGhpcztcblxuICAgIF90aGlzLnByZWRpY2F0ZSA9IHByZWRpY2F0ZTtcbiAgICBfdGhpcy50aGlzQXJnID0gdGhpc0FyZztcbiAgICBfdGhpcy5jb3VudCA9IDA7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgRmlsdGVyU3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICB2YXIgcmVzdWx0O1xuXG4gICAgdHJ5IHtcbiAgICAgIHJlc3VsdCA9IHRoaXMucHJlZGljYXRlLmNhbGwodGhpcy50aGlzQXJnLCB2YWx1ZSwgdGhpcy5jb3VudCsrKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRoaXMuZGVzdGluYXRpb24uZXJyb3IoZXJyKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAocmVzdWx0KSB7XG4gICAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQodmFsdWUpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gRmlsdGVyU3Vic2NyaWJlcjtcbn0oU3Vic2NyaWJlcik7XG4vKiogUFVSRV9JTVBPUlRTX1NUQVJUIHRzbGliLF9TdWJzY3JpYmVyLF91dGlsX0FyZ3VtZW50T3V0T2ZSYW5nZUVycm9yLF9vYnNlcnZhYmxlX2VtcHR5IFBVUkVfSU1QT1JUU19FTkQgKi9cblxuXG5mdW5jdGlvbiB0YWtlKGNvdW50KSB7XG4gIHJldHVybiBmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgaWYgKGNvdW50ID09PSAwKSB7XG4gICAgICByZXR1cm4gZW1wdHkkMSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gc291cmNlLmxpZnQobmV3IFRha2VPcGVyYXRvcihjb3VudCkpO1xuICAgIH1cbiAgfTtcbn1cblxudmFyIFRha2VPcGVyYXRvciA9IC8qQF9fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFRha2VPcGVyYXRvcih0b3RhbCkge1xuICAgIHRoaXMudG90YWwgPSB0b3RhbDtcblxuICAgIGlmICh0aGlzLnRvdGFsIDwgMCkge1xuICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50T3V0T2ZSYW5nZUVycm9yKCk7XG4gICAgfVxuICB9XG5cbiAgVGFrZU9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBUYWtlU3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLnRvdGFsKSk7XG4gIH07XG5cbiAgcmV0dXJuIFRha2VPcGVyYXRvcjtcbn0oKTtcblxudmFyIFRha2VTdWJzY3JpYmVyID0gLypAX19QVVJFX18qL2Z1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKFRha2VTdWJzY3JpYmVyLCBfc3VwZXIpO1xuXG4gIGZ1bmN0aW9uIFRha2VTdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCB0b3RhbCkge1xuICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKSB8fCB0aGlzO1xuXG4gICAgX3RoaXMudG90YWwgPSB0b3RhbDtcbiAgICBfdGhpcy5jb3VudCA9IDA7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgVGFrZVN1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgdmFyIHRvdGFsID0gdGhpcy50b3RhbDtcbiAgICB2YXIgY291bnQgPSArK3RoaXMuY291bnQ7XG5cbiAgICBpZiAoY291bnQgPD0gdG90YWwpIHtcbiAgICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dCh2YWx1ZSk7XG5cbiAgICAgIGlmIChjb3VudCA9PT0gdG90YWwpIHtcbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBUYWtlU3Vic2NyaWJlcjtcbn0oU3Vic2NyaWJlcik7XG4vKiogUFVSRV9JTVBPUlRTX1NUQVJUIHRzbGliLF9TdWJzY3JpYmVyLF9TdWJzY3JpcHRpb24gUFVSRV9JTVBPUlRTX0VORCAqL1xuXG5cbmZ1bmN0aW9uIGZpbmFsaXplKGNhbGxiYWNrKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgcmV0dXJuIHNvdXJjZS5saWZ0KG5ldyBGaW5hbGx5T3BlcmF0b3IoY2FsbGJhY2spKTtcbiAgfTtcbn1cblxudmFyIEZpbmFsbHlPcGVyYXRvciA9IC8qQF9fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEZpbmFsbHlPcGVyYXRvcihjYWxsYmFjaykge1xuICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgfVxuXG4gIEZpbmFsbHlPcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgRmluYWxseVN1YnNjcmliZXIoc3Vic2NyaWJlciwgdGhpcy5jYWxsYmFjaykpO1xuICB9O1xuXG4gIHJldHVybiBGaW5hbGx5T3BlcmF0b3I7XG59KCk7XG5cbnZhciBGaW5hbGx5U3Vic2NyaWJlciA9IC8qQF9fUFVSRV9fKi9mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhGaW5hbGx5U3Vic2NyaWJlciwgX3N1cGVyKTtcblxuICBmdW5jdGlvbiBGaW5hbGx5U3Vic2NyaWJlcihkZXN0aW5hdGlvbiwgY2FsbGJhY2spIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbikgfHwgdGhpcztcblxuICAgIF90aGlzLmFkZChuZXcgU3Vic2NyaXB0aW9uKGNhbGxiYWNrKSk7XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICByZXR1cm4gRmluYWxseVN1YnNjcmliZXI7XG59KFN1YnNjcmliZXIpO1xuLyoqIFBVUkVfSU1QT1JUU19TVEFSVCB0c2xpYixfU3Vic2NyaWJlciBQVVJFX0lNUE9SVFNfRU5EICovXG5cblxuZnVuY3Rpb24gdGFrZVdoaWxlKHByZWRpY2F0ZSwgaW5jbHVzaXZlKSB7XG4gIGlmIChpbmNsdXNpdmUgPT09IHZvaWQgMCkge1xuICAgIGluY2x1c2l2ZSA9IGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICByZXR1cm4gc291cmNlLmxpZnQobmV3IFRha2VXaGlsZU9wZXJhdG9yKHByZWRpY2F0ZSwgaW5jbHVzaXZlKSk7XG4gIH07XG59XG5cbnZhciBUYWtlV2hpbGVPcGVyYXRvciA9IC8qQF9fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFRha2VXaGlsZU9wZXJhdG9yKHByZWRpY2F0ZSwgaW5jbHVzaXZlKSB7XG4gICAgdGhpcy5wcmVkaWNhdGUgPSBwcmVkaWNhdGU7XG4gICAgdGhpcy5pbmNsdXNpdmUgPSBpbmNsdXNpdmU7XG4gIH1cblxuICBUYWtlV2hpbGVPcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgVGFrZVdoaWxlU3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLnByZWRpY2F0ZSwgdGhpcy5pbmNsdXNpdmUpKTtcbiAgfTtcblxuICByZXR1cm4gVGFrZVdoaWxlT3BlcmF0b3I7XG59KCk7XG5cbnZhciBUYWtlV2hpbGVTdWJzY3JpYmVyID0gLypAX19QVVJFX18qL2Z1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKFRha2VXaGlsZVN1YnNjcmliZXIsIF9zdXBlcik7XG5cbiAgZnVuY3Rpb24gVGFrZVdoaWxlU3Vic2NyaWJlcihkZXN0aW5hdGlvbiwgcHJlZGljYXRlLCBpbmNsdXNpdmUpIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbikgfHwgdGhpcztcblxuICAgIF90aGlzLnByZWRpY2F0ZSA9IHByZWRpY2F0ZTtcbiAgICBfdGhpcy5pbmNsdXNpdmUgPSBpbmNsdXNpdmU7XG4gICAgX3RoaXMuaW5kZXggPSAwO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIFRha2VXaGlsZVN1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgdmFyIGRlc3RpbmF0aW9uID0gdGhpcy5kZXN0aW5hdGlvbjtcbiAgICB2YXIgcmVzdWx0O1xuXG4gICAgdHJ5IHtcbiAgICAgIHJlc3VsdCA9IHRoaXMucHJlZGljYXRlKHZhbHVlLCB0aGlzLmluZGV4KyspO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgZGVzdGluYXRpb24uZXJyb3IoZXJyKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLm5leHRPckNvbXBsZXRlKHZhbHVlLCByZXN1bHQpO1xuICB9O1xuXG4gIFRha2VXaGlsZVN1YnNjcmliZXIucHJvdG90eXBlLm5leHRPckNvbXBsZXRlID0gZnVuY3Rpb24gKHZhbHVlLCBwcmVkaWNhdGVSZXN1bHQpIHtcbiAgICB2YXIgZGVzdGluYXRpb24gPSB0aGlzLmRlc3RpbmF0aW9uO1xuXG4gICAgaWYgKEJvb2xlYW4ocHJlZGljYXRlUmVzdWx0KSkge1xuICAgICAgZGVzdGluYXRpb24ubmV4dCh2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0aGlzLmluY2x1c2l2ZSkge1xuICAgICAgICBkZXN0aW5hdGlvbi5uZXh0KHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIFRha2VXaGlsZVN1YnNjcmliZXI7XG59KFN1YnNjcmliZXIpO1xuLyoqIFBVUkVfSU1QT1JUU19TVEFSVCAgUFVSRV9JTVBPUlRTX0VORCAqL1xuXG5cbnZhciBUaW1lb3V0RXJyb3JJbXBsID0gLypAX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gVGltZW91dEVycm9ySW1wbCgpIHtcbiAgICBFcnJvci5jYWxsKHRoaXMpO1xuICAgIHRoaXMubWVzc2FnZSA9ICdUaW1lb3V0IGhhcyBvY2N1cnJlZCc7XG4gICAgdGhpcy5uYW1lID0gJ1RpbWVvdXRFcnJvcic7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBUaW1lb3V0RXJyb3JJbXBsLnByb3RvdHlwZSA9IC8qQF9fUFVSRV9fKi9PYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSk7XG4gIHJldHVybiBUaW1lb3V0RXJyb3JJbXBsO1xufSgpO1xuXG52YXIgVGltZW91dEVycm9yID0gVGltZW91dEVycm9ySW1wbDtcbi8qKiBQVVJFX0lNUE9SVFNfU1RBUlQgdHNsaWIsX3NjaGVkdWxlcl9hc3luYyxfdXRpbF9pc0RhdGUsX2lubmVyU3Vic2NyaWJlIFBVUkVfSU1QT1JUU19FTkQgKi9cblxuZnVuY3Rpb24gdGltZW91dFdpdGgoZHVlLCB3aXRoT2JzZXJ2YWJsZSwgc2NoZWR1bGVyKSB7XG4gIGlmIChzY2hlZHVsZXIgPT09IHZvaWQgMCkge1xuICAgIHNjaGVkdWxlciA9IGFzeW5jO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICB2YXIgYWJzb2x1dGVUaW1lb3V0ID0gaXNEYXRlKGR1ZSk7XG4gICAgdmFyIHdhaXRGb3IgPSBhYnNvbHV0ZVRpbWVvdXQgPyArZHVlIC0gc2NoZWR1bGVyLm5vdygpIDogTWF0aC5hYnMoZHVlKTtcbiAgICByZXR1cm4gc291cmNlLmxpZnQobmV3IFRpbWVvdXRXaXRoT3BlcmF0b3Iod2FpdEZvciwgYWJzb2x1dGVUaW1lb3V0LCB3aXRoT2JzZXJ2YWJsZSwgc2NoZWR1bGVyKSk7XG4gIH07XG59XG5cbnZhciBUaW1lb3V0V2l0aE9wZXJhdG9yID0gLypAX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gVGltZW91dFdpdGhPcGVyYXRvcih3YWl0Rm9yLCBhYnNvbHV0ZVRpbWVvdXQsIHdpdGhPYnNlcnZhYmxlLCBzY2hlZHVsZXIpIHtcbiAgICB0aGlzLndhaXRGb3IgPSB3YWl0Rm9yO1xuICAgIHRoaXMuYWJzb2x1dGVUaW1lb3V0ID0gYWJzb2x1dGVUaW1lb3V0O1xuICAgIHRoaXMud2l0aE9ic2VydmFibGUgPSB3aXRoT2JzZXJ2YWJsZTtcbiAgICB0aGlzLnNjaGVkdWxlciA9IHNjaGVkdWxlcjtcbiAgfVxuXG4gIFRpbWVvdXRXaXRoT3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoc3Vic2NyaWJlciwgc291cmNlKSB7XG4gICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IFRpbWVvdXRXaXRoU3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLmFic29sdXRlVGltZW91dCwgdGhpcy53YWl0Rm9yLCB0aGlzLndpdGhPYnNlcnZhYmxlLCB0aGlzLnNjaGVkdWxlcikpO1xuICB9O1xuXG4gIHJldHVybiBUaW1lb3V0V2l0aE9wZXJhdG9yO1xufSgpO1xuXG52YXIgVGltZW91dFdpdGhTdWJzY3JpYmVyID0gLypAX19QVVJFX18qL2Z1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKFRpbWVvdXRXaXRoU3Vic2NyaWJlciwgX3N1cGVyKTtcblxuICBmdW5jdGlvbiBUaW1lb3V0V2l0aFN1YnNjcmliZXIoZGVzdGluYXRpb24sIGFic29sdXRlVGltZW91dCwgd2FpdEZvciwgd2l0aE9ic2VydmFibGUsIHNjaGVkdWxlcikge1xuICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKSB8fCB0aGlzO1xuXG4gICAgX3RoaXMuYWJzb2x1dGVUaW1lb3V0ID0gYWJzb2x1dGVUaW1lb3V0O1xuICAgIF90aGlzLndhaXRGb3IgPSB3YWl0Rm9yO1xuICAgIF90aGlzLndpdGhPYnNlcnZhYmxlID0gd2l0aE9ic2VydmFibGU7XG4gICAgX3RoaXMuc2NoZWR1bGVyID0gc2NoZWR1bGVyO1xuXG4gICAgX3RoaXMuc2NoZWR1bGVUaW1lb3V0KCk7XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBUaW1lb3V0V2l0aFN1YnNjcmliZXIuZGlzcGF0Y2hUaW1lb3V0ID0gZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcbiAgICB2YXIgd2l0aE9ic2VydmFibGUgPSBzdWJzY3JpYmVyLndpdGhPYnNlcnZhYmxlO1xuXG4gICAgc3Vic2NyaWJlci5fdW5zdWJzY3JpYmVBbmRSZWN5Y2xlKCk7XG5cbiAgICBzdWJzY3JpYmVyLmFkZChpbm5lclN1YnNjcmliZSh3aXRoT2JzZXJ2YWJsZSwgbmV3IFNpbXBsZUlubmVyU3Vic2NyaWJlcihzdWJzY3JpYmVyKSkpO1xuICB9O1xuXG4gIFRpbWVvdXRXaXRoU3Vic2NyaWJlci5wcm90b3R5cGUuc2NoZWR1bGVUaW1lb3V0ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBhY3Rpb24gPSB0aGlzLmFjdGlvbjtcblxuICAgIGlmIChhY3Rpb24pIHtcbiAgICAgIHRoaXMuYWN0aW9uID0gYWN0aW9uLnNjaGVkdWxlKHRoaXMsIHRoaXMud2FpdEZvcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYWRkKHRoaXMuYWN0aW9uID0gdGhpcy5zY2hlZHVsZXIuc2NoZWR1bGUoVGltZW91dFdpdGhTdWJzY3JpYmVyLmRpc3BhdGNoVGltZW91dCwgdGhpcy53YWl0Rm9yLCB0aGlzKSk7XG4gICAgfVxuICB9O1xuXG4gIFRpbWVvdXRXaXRoU3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBpZiAoIXRoaXMuYWJzb2x1dGVUaW1lb3V0KSB7XG4gICAgICB0aGlzLnNjaGVkdWxlVGltZW91dCgpO1xuICAgIH1cblxuICAgIF9zdXBlci5wcm90b3R5cGUuX25leHQuY2FsbCh0aGlzLCB2YWx1ZSk7XG4gIH07XG5cbiAgVGltZW91dFdpdGhTdWJzY3JpYmVyLnByb3RvdHlwZS5fdW5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5hY3Rpb24gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5zY2hlZHVsZXIgPSBudWxsO1xuICAgIHRoaXMud2l0aE9ic2VydmFibGUgPSBudWxsO1xuICB9O1xuXG4gIHJldHVybiBUaW1lb3V0V2l0aFN1YnNjcmliZXI7XG59KFNpbXBsZU91dGVyU3Vic2NyaWJlcik7XG4vKiogUFVSRV9JTVBPUlRTX1NUQVJUIF9zY2hlZHVsZXJfYXN5bmMsX3V0aWxfVGltZW91dEVycm9yLF90aW1lb3V0V2l0aCxfb2JzZXJ2YWJsZV90aHJvd0Vycm9yIFBVUkVfSU1QT1JUU19FTkQgKi9cblxuXG5mdW5jdGlvbiB0aW1lb3V0KGR1ZSwgc2NoZWR1bGVyKSB7XG4gIGlmIChzY2hlZHVsZXIgPT09IHZvaWQgMCkge1xuICAgIHNjaGVkdWxlciA9IGFzeW5jO1xuICB9XG5cbiAgcmV0dXJuIHRpbWVvdXRXaXRoKGR1ZSwgdGhyb3dFcnJvcihuZXcgVGltZW91dEVycm9yKCkpLCBzY2hlZHVsZXIpO1xufVxuXG5jb25zdCBzaW11bGF0aW9ucyQgPSBuZXcgU3ViamVjdCgpO1xuXG5mdW5jdGlvbiBzaW11bGF0ZShzeXN0ZW0sIG5ldHdvcmssIHRyYW5zYWN0aW9uKSB7XG4gIGlmICh0aGlzLl9kZXN0cm95ZWQpIHRocm93IG5ldyBFcnJvcignVGhlIFdlYlNvY2tldCBpbnN0YW5jZSBoYXMgYmVlbiBkZXN0cm95ZWQsIHJlLWluaXRpYWxpemUgdG8gY29udGludWUgbWFraW5nIHJlcXVlc3RzLicpO1xuICBjb25zdCBpZCA9IG5hbm9pZCgpOyAvLyBzZW5kIHBheWxvYWQgdG8gc2VydmVyXG5cbiAgdGhpcy5fc2VuZE1lc3NhZ2Uoe1xuICAgIGNhdGVnb3J5Q29kZTogJ3NpbXVsYXRlJyxcbiAgICBldmVudENvZGU6ICd0eFNpbXVsYXRpb24nLFxuICAgIGV2ZW50SWQ6IGlkLFxuICAgIHRyYW5zYWN0aW9uOiB0cmFuc2FjdGlvblxuICB9KTtcblxuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIHNpbXVsYXRpb25zJC5waXBlKGZpbHRlcigoe1xuICAgICAgZXZlbnRJZFxuICAgIH0pID0+IHtcbiAgICAgIHJldHVybiBldmVudElkID09PSBpZDtcbiAgICB9KSwgdGFrZSgxKSkuc3Vic2NyaWJlKHtcbiAgICAgIG5leHQ6ICh7XG4gICAgICAgIHRyYW5zYWN0aW9uXG4gICAgICB9KSA9PiByZXNvbHZlKHRyYW5zYWN0aW9uKSxcbiAgICAgIGVycm9yOiAoe1xuICAgICAgICBlcnJvclxuICAgICAgfSkgPT4gcmVqZWN0KGVycm9yLm1lc3NhZ2UpXG4gICAgfSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBtdWx0aVNpbSh0cmFuc2FjdGlvbnMpIHtcbiAgaWYgKHRoaXMuX2Rlc3Ryb3llZCkgdGhyb3cgbmV3IEVycm9yKCdUaGUgV2ViU29ja2V0IGluc3RhbmNlIGhhcyBiZWVuIGRlc3Ryb3llZCwgcmUtaW5pdGlhbGl6ZSB0byBjb250aW51ZSBtYWtpbmcgcmVxdWVzdHMuJyk7XG4gIGNvbnN0IGlkID0gbmFub2lkKCk7IC8vIHNlbmQgcGF5bG9hZCB0byBzZXJ2ZXJcblxuICB0aGlzLl9zZW5kTWVzc2FnZSh7XG4gICAgY2F0ZWdvcnlDb2RlOiAnc2ltdWxhdGUnLFxuICAgIGV2ZW50Q29kZTogJ3R4U2ltdWxhdGlvbicsXG4gICAgZXZlbnRJZDogaWQsXG4gICAgdHJhbnNhY3Rpb246IHRyYW5zYWN0aW9uc1xuICB9KTtcblxuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIHNpbXVsYXRpb25zJC5waXBlKGZpbHRlcigoe1xuICAgICAgZXZlbnRJZFxuICAgIH0pID0+IHtcbiAgICAgIHJldHVybiBldmVudElkID09PSBpZDtcbiAgICB9KSwgdGFrZSgxKSkuc3Vic2NyaWJlKHtcbiAgICAgIG5leHQ6ICh7XG4gICAgICAgIHRyYW5zYWN0aW9uXG4gICAgICB9KSA9PiByZXNvbHZlKHRyYW5zYWN0aW9uKSxcbiAgICAgIGVycm9yOiAoe1xuICAgICAgICBlcnJvclxuICAgICAgfSkgPT4gcmVqZWN0KGVycm9yLm1lc3NhZ2UpXG4gICAgfSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiB1bnN1YnNjcmliZShhZGRyZXNzT3JIYXNoKSB7XG4gIGlmICh0aGlzLl9kZXN0cm95ZWQpIHRocm93IG5ldyBFcnJvcignVGhlIFdlYlNvY2tldCBpbnN0YW5jZSBoYXMgYmVlbiBkZXN0cm95ZWQsIHJlLWluaXRpYWxpemUgdG8gY29udGludWUgbWFraW5nIHJlcXVlc3RzLicpO1xuICBjb25zdCBhZGRyZXNzID0gaXNBZGRyZXNzKHRoaXMuX3N5c3RlbSwgYWRkcmVzc09ySGFzaCk7XG4gIGNvbnN0IHR4aWQgPSBpc1R4aWQodGhpcy5fc3lzdGVtLCBhZGRyZXNzT3JIYXNoKTsgLy8gY2hlY2sgaWYgaXQgaXMgYW4gYWRkcmVzcyBvciBhIGhhc2hcblxuICBpZiAoYWRkcmVzcykge1xuICAgIGNvbnN0IG5vcm1hbGl6ZWRBZGRyZXNzID0gdGhpcy5fc3lzdGVtID09PSAnZXRoZXJldW0nID8gYWRkcmVzc09ySGFzaC50b0xvd2VyQ2FzZSgpIDogYWRkcmVzc09ySGFzaDsgLy8gcmVtb3ZlIGFkZHJlc3MgZnJvbSBhY2NvdW50c1xuXG4gICAgdGhpcy53YXRjaGVkQWNjb3VudHMgPSB0aGlzLndhdGNoZWRBY2NvdW50cy5maWx0ZXIoYWMgPT4gYWMuYWRkcmVzcyAhPT0gbm9ybWFsaXplZEFkZHJlc3MpOyAvLyByZW1vdmUgY29uZmlndXJhdGlvbiBmcm9tIG1lbW9yeVxuXG4gICAgdGhpcy5jb25maWd1cmF0aW9ucy5kZWxldGUobm9ybWFsaXplZEFkZHJlc3MpOyAvLyBsb2dFdmVudCB0byBzZXJ2ZXJcblxuICAgIHRoaXMuX3NlbmRNZXNzYWdlKHtcbiAgICAgIGNhdGVnb3J5Q29kZTogJ2FjY291bnRBZGRyZXNzJyxcbiAgICAgIGV2ZW50Q29kZTogJ3Vud2F0Y2gnLFxuICAgICAgYWNjb3VudDoge1xuICAgICAgICBhZGRyZXNzOiBub3JtYWxpemVkQWRkcmVzc1xuICAgICAgfVxuICAgIH0pO1xuICB9IGVsc2UgaWYgKHR4aWQpIHtcbiAgICAvLyByZW1vdmUgdHJhbnNhY3Rpb24gZnJvbSB0cmFuc2FjdGlvbnNcbiAgICB0aGlzLndhdGNoZWRUcmFuc2FjdGlvbnMgPSB0aGlzLndhdGNoZWRUcmFuc2FjdGlvbnMuZmlsdGVyKHR4ID0+IHR4Lmhhc2ggIT09IGFkZHJlc3NPckhhc2gpO1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uSWQgPSB0aGlzLl9zeXN0ZW0gPT09ICdldGhlcmV1bScgPyB7XG4gICAgICBoYXNoOiBhZGRyZXNzT3JIYXNoXG4gICAgfSA6IHtcbiAgICAgIHR4aWQ6IGFkZHJlc3NPckhhc2hcbiAgICB9O1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uID0geyAuLi50cmFuc2FjdGlvbklkLFxuICAgICAgaWQ6IGFkZHJlc3NPckhhc2gsXG4gICAgICBzdGF0dXM6ICd1bnN1YnNjcmliZWQnXG4gICAgfTsgLy8gbG9nRXZlbnQgdG8gc2VydmVyXG5cbiAgICB0aGlzLl9zZW5kTWVzc2FnZSh7XG4gICAgICBjYXRlZ29yeUNvZGU6ICdhY3RpdmVUcmFuc2FjdGlvbicsXG4gICAgICBldmVudENvZGU6ICd1bndhdGNoJyxcbiAgICAgIHRyYW5zYWN0aW9uXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvciB0cnlpbmcgdG8gdW5zdWJzY3JpYmUgJHthZGRyZXNzT3JIYXNofTogbm90IGEgdmFsaWQgYWRkcmVzcyBvciB0cmFuc2FjdGlvbiBpZC9oYXNoYCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY29uZmlndXJhdGlvbihjb25maWcpIHtcbiAgaWYgKHRoaXMuX2Rlc3Ryb3llZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignVGhlIFdlYlNvY2tldCBpbnN0YW5jZSBoYXMgYmVlbiBkZXN0cm95ZWQsIHJlLWluaXRpYWxpemUgdG8gY29udGludWUgbWFraW5nIHJlcXVlc3RzLicpO1xuICB9XG5cbiAgY29uc3QgY2FzZWRTY29wZSA9IHRoaXMuX3N5c3RlbSA9PT0gJ2V0aGVyZXVtJyA/IGNvbmZpZy5zY29wZS50b0xvd2VyQ2FzZSgpIDogY29uZmlnLnNjb3BlOyAvLyByZXNvbHZlIHByZXZpb3VzIGNvbmZpZ3VyYXRpb24gaWYgZXhpc3RzXG5cbiAgY29uc3QgcHJldmlvdXNDb25maWd1cmF0aW9uID0gdGhpcy5jb25maWd1cmF0aW9ucy5nZXQoY2FzZWRTY29wZSk7XG4gIHByZXZpb3VzQ29uZmlndXJhdGlvbiAmJiBwcmV2aW91c0NvbmZpZ3VyYXRpb24uc3Vic2NyaXB0aW9uICYmIHByZXZpb3VzQ29uZmlndXJhdGlvbi5zdWJzY3JpcHRpb24ubmV4dCgpO1xuICBjb25zdCBzdWJzY3JpcHRpb24gPSBuZXcgU3ViamVjdCgpOyAvLyBjcmVhdGUgZW1pdHRlciBmb3IgdHJhbnNhY3Rpb25cblxuICBjb25zdCBlbWl0dGVyID0gY29uZmlnLndhdGNoQWRkcmVzcyA/IHtcbiAgICBlbWl0dGVyOiBjcmVhdGVFbWl0dGVyKClcbiAgfSA6IHt9O1xuICB0aGlzLmNvbmZpZ3VyYXRpb25zLnNldChjYXNlZFNjb3BlLCB7IC4uLmNvbmZpZyxcbiAgICAuLi5lbWl0dGVyLFxuICAgIHN1YnNjcmlwdGlvblxuICB9KTtcblxuICB0aGlzLl9zZW5kTWVzc2FnZSh7XG4gICAgY2F0ZWdvcnlDb2RlOiAnY29uZmlncycsXG4gICAgZXZlbnRDb2RlOiAncHV0JyxcbiAgICBjb25maWdcbiAgfSk7XG5cbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBzdWJzY3JpcHRpb24ucGlwZSh0YWtlKDEpLCB0aW1lb3V0KDUwMDApKS5zdWJzY3JpYmUoe1xuICAgICAgbmV4dDogKCkgPT4gcmVzb2x2ZSh7IC4uLmVtaXR0ZXIsXG4gICAgICAgIGRldGFpbHM6IHtcbiAgICAgICAgICBjb25maWdcbiAgICAgICAgfVxuICAgICAgfSksXG4gICAgICBlcnJvcjogZXJyb3IgPT4ge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gZXJyb3IubWVzc2FnZSA9PT0gJ1RpbWVvdXQgaGFzIG9jY3VycmVkJyA/IGBDb25maWd1cmF0aW9uIHdpdGggc2NvcGU6ICR7Y29uZmlnLnNjb3BlfSBoYXMgYmVlbiBzZW50IHRvIHRoZSBCbG9ja25hdGl2ZSBzZXJ2ZXIsIGJ1dCBoYXMgbm90IHJlY2VpdmVkIGEgcmVwbHkgd2l0aGluIDUgc2Vjb25kcy5gIDogZXJyb3IubWVzc2FnZTtcblxuICAgICAgICBpZiAodGhpcy5fb25lcnJvcikge1xuICAgICAgICAgIHRoaXMuX29uZXJyb3Ioe1xuICAgICAgICAgICAgbWVzc2FnZVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgcmVzb2x2ZShgRXJyb3I6ICR7bWVzc2FnZX1gKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZWplY3QobWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHN1YnNjcmliZShzdWJzY3JpcHRpb24pIHtcbiAgY29uc3Qge1xuICAgIGlkLFxuICAgIGNoYWluSWQsXG4gICAgdHlwZVxuICB9ID0gc3Vic2NyaXB0aW9uO1xuXG4gIGlmICghbmV0d29ya05hbWUoJ2V0aGVyZXVtJywgcGFyc2VJbnQoY2hhaW5JZCwgMTYpKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgY2hhaW5JZDogJHtjaGFpbklkfSBpcyBhbiB1bnN1cHBvcnRlZCBuZXR3b3JrYCk7XG4gIH1cblxuICBpZiAoIXRoaXMuY29ubmVjdGlvbnNbY2hhaW5JZF0pIHtcbiAgICB0aGlzLmNvbm5lY3Rpb25zW2NoYWluSWRdID0gbmV3IHRoaXMuQmxvY2tuYXRpdmUoe1xuICAgICAgc3lzdGVtOiAnZXRoZXJldW0nLFxuICAgICAgbmV0d29ya0lkOiBwYXJzZUludChjaGFpbklkLCAxNiksXG4gICAgICBkYXBwSWQ6IHRoaXMuYXBpS2V5LFxuICAgICAgd3M6IHRoaXMud3MsXG4gICAgICBhcGlVcmw6IHRoaXMuYXBpVXJsLFxuICAgICAgdHJhbnNhY3Rpb25IYW5kbGVyczogWyh7XG4gICAgICAgIHRyYW5zYWN0aW9uXG4gICAgICB9KSA9PiB7XG4gICAgICAgIHRoaXMub25UcmFuc2FjdGlvbiQubmV4dCh0cmFuc2FjdGlvbik7XG4gICAgICB9XSxcbiAgICAgIG9uZXJyb3I6IGVycm9yID0+IHRoaXMuZXJyb3JzJC5uZXh0KGVycm9yKVxuICAgIH0pO1xuICB9XG5cbiAgY29uc3Qgc2RrID0gdGhpcy5jb25uZWN0aW9uc1tjaGFpbklkXTtcblxuICBpZiAodHlwZSA9PT0gJ2FjY291bnQnKSB7XG4gICAgY29uc3Qge1xuICAgICAgZmlsdGVycyA9IFtdLFxuICAgICAgYWJpXG4gICAgfSA9IHN1YnNjcmlwdGlvbjtcbiAgICBzZGsuY29uZmlndXJhdGlvbih7XG4gICAgICBzY29wZTogaWQsXG4gICAgICBmaWx0ZXJzLFxuICAgICAgLi4uKGFiaSA/IHtcbiAgICAgICAgYWJpXG4gICAgICB9IDoge30pLFxuICAgICAgd2F0Y2hBZGRyZXNzOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXMudHJhbnNhY3Rpb25zJC5waXBlKGZpbHRlcigoe1xuICAgICAgd2F0Y2hlZEFkZHJlc3NcbiAgICB9KSA9PiB3YXRjaGVkQWRkcmVzcyA9PT0gaWQpLCBmaW5hbGl6ZSgoKSA9PiB7XG4gICAgICB0aGlzLnVuc3Vic2NyaWJlKHtcbiAgICAgICAgaWQsXG4gICAgICAgIGNoYWluSWRcbiAgICAgIH0pO1xuICAgIH0pKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCB7XG4gICAgICBlbWl0dGVyXG4gICAgfSA9IHNkay50cmFuc2FjdGlvbihpZCk7XG4gICAgcmV0dXJuIGZyb21FdmVudCggLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgLy8gQHRzLWlnbm9yZSAtIHN0cmluZyBkb2VzIG5vdCBtYXRjaCBzcGVjaWZpYyBldmVudGNvZGUgc3RyaW5nXG4gICAgZW1pdHRlciwgJ2FsbCcpLnBpcGUoIC8vIGF1dG9tYXRpY2FsbHkgY29tcGxldGUgc3RyZWFtIG9uIGEgZmluYWxpemVkIHN0YXR1c1xuICAgIHRha2VXaGlsZSgoe1xuICAgICAgc3RhdHVzXG4gICAgfSkgPT4gc3RhdHVzICE9PSAnY29uZmlybWVkJyAmJiBzdGF0dXMgIT09ICdmYWlsZWQnICYmIHN0YXR1cyAhPT0gJ2Ryb3BwZWQnLCB0cnVlKSwgLy8gY2xlYW51cCBzdWJzY3JpcHRpb24gYW5kIFNESyBvbiBjb21wbGV0aW9uXG4gICAgZmluYWxpemUoKCkgPT4ge1xuICAgICAgdGhpcy51bnN1YnNjcmliZSh7XG4gICAgICAgIGlkLFxuICAgICAgICBjaGFpbklkXG4gICAgICB9KTtcbiAgICB9KSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdW5zdWJzY3JpYmUkMShvcHRpb25zKSB7XG4gIGNvbnN0IHtcbiAgICBpZCxcbiAgICBjaGFpbklkLFxuICAgIHRpbWVvdXQgPSAwXG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCB0aW1lJCA9IHRpbWVyKHRpbWVvdXQpO1xuICBjb25zdCB0cmFuc2FjdGlvbkV2ZW50JCA9IHRoaXMudHJhbnNhY3Rpb25zJC5waXBlKGZpbHRlcigoe1xuICAgIGhhc2gsXG4gICAgd2F0Y2hlZEFkZHJlc3NcbiAgfSkgPT4gaGFzaCA9PT0gaWQgfHwgd2F0Y2hlZEFkZHJlc3MgPT09IGlkKSk7XG4gIG1lcmdlKHRyYW5zYWN0aW9uRXZlbnQkLCB0aW1lJCkucGlwZSh0YWtlKDEpKSAvLyB0YWtlIGp1c3QgZmlyc3QgZXZlbnRcbiAgLnN1YnNjcmliZShyZXMgPT4ge1xuICAgIC8vIGlmIG51bWJlciwgdGhlbiB0aW1lb3V0IHdpdGggbm8gdHJhbnNhY3Rpb24gZXZlbnRzLCBzbyBnbyBhaGVhZCBhbmQgdW5zdWJcbiAgICBpZiAodHlwZW9mIHJlcyA9PT0gJ251bWJlcicpIHtcbiAgICAgIGNvbnN0IHNka0Nvbm5lY3Rpb25zID0gT2JqZWN0LmVudHJpZXModGhpcy5jb25uZWN0aW9ucykuZmlsdGVyKChbY2hhaW5JZCwgc2RrXSkgPT4gc2RrICE9PSBudWxsKTtcbiAgICAgIHNka0Nvbm5lY3Rpb25zLmZvckVhY2goKFtjb25uZWN0aW9uQ2hhaW5JZCwgc2RrXSkgPT4ge1xuICAgICAgICAvLyBpZiBjaGFpbklkIGlzIHBhc3NlZCBhbmQgaXQgZG9lc24ndCBtYXRjaCwgdGhlbiBubyB1bnN1YiAocmV0dXJuIGVhcmx5KVxuICAgICAgICBpZiAoY2hhaW5JZCAmJiBjb25uZWN0aW9uQ2hhaW5JZCAhPT0gY2hhaW5JZCkgcmV0dXJuO1xuICAgICAgICBzZGsudW5zdWJzY3JpYmUoaWQpOyAvLyBpZiBubyByZW1haW5pbmcgc3Vic2NyaXB0aW9ucywgZGVzdHJveSBjb25uZWN0aW9uIGFuZCBzZXQgdG8gbnVsbFxuXG4gICAgICAgIGlmICghc2RrLndhdGNoZWRBY2NvdW50cy5sZW5ndGggJiYgIXNkay53YXRjaGVkVHJhbnNhY3Rpb25zLmxlbmd0aCAmJiAhc2RrLmNvbmZpZ3VyYXRpb25zLnNpemUpIHtcbiAgICAgICAgICBzZGsuZGVzdHJveSgpO1xuICAgICAgICAgIHRoaXMuY29ubmVjdGlvbnNbY29ubmVjdGlvbkNoYWluSWRdID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIG90aGVyd2lzZSBhIHRyYW5zYWN0aW9uIGV2ZW50IHJlY2VpdmVkLCBzbyBjYWxsIHVuc3ViIGFnYWluIGZvciBhbm90aGVyIHRpbWVvdXRcbiAgICAgIHRoaXMudW5zdWJzY3JpYmUob3B0aW9ucyk7XG4gICAgfVxuICB9KTtcbn0gLy8qKkV4cGVyaW1lbnRhbCBBUEkgdGhhdCBpcyBub3QgeWV0IGZpbmFsaXplZCBhbmQgaXMgaW4gQkVUQSovXG5cblxuY2xhc3MgTXVsdGlDaGFpbiB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMsIEJsb2NrbmF0aXZlKSB7XG4gICAgY29uc3Qge1xuICAgICAgd3NcbiAgICB9ID0gb3B0aW9ucztcbiAgICBjb25zdCB7XG4gICAgICBhcGlLZXlcbiAgICB9ID0gb3B0aW9ucztcbiAgICBjb25zdCB7XG4gICAgICBhcGlVcmxcbiAgICB9ID0gb3B0aW9ucztcbiAgICB0aGlzLmFwaUtleSA9IGFwaUtleTtcbiAgICB0aGlzLmFwaVVybCA9IGFwaVVybDtcbiAgICB0aGlzLndzID0gd3M7XG4gICAgdGhpcy5jb25uZWN0aW9ucyA9IHt9O1xuICAgIHRoaXMub25UcmFuc2FjdGlvbiQgPSBuZXcgU3ViamVjdCgpO1xuICAgIHRoaXMudHJhbnNhY3Rpb25zJCA9IHRoaXMub25UcmFuc2FjdGlvbiQuYXNPYnNlcnZhYmxlKCk7XG4gICAgdGhpcy5lcnJvcnMkID0gbmV3IFN1YmplY3QoKTtcbiAgICB0aGlzLkJsb2NrbmF0aXZlID0gQmxvY2tuYXRpdmU7XG4gICAgdGhpcy5zdWJzY3JpYmUgPSBzdWJzY3JpYmUuYmluZCh0aGlzKTtcbiAgICB0aGlzLnVuc3Vic2NyaWJlID0gdW5zdWJzY3JpYmUkMS5iaW5kKHRoaXMpO1xuICB9XG5cbn1cblxudmFyIHZlcnNpb24gPSBcIjQuNi45XCI7XG5cbmZ1bmN0aW9uIHNlbmRNZXNzYWdlKG1zZykge1xuICBpZiAodGhpcy5fcXVldWVkTWVzc2FnZXMubGVuZ3RoID4gUVVFVUVfTElNSVQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFF1ZXVlIGxpbWl0IG9mICR7UVVFVUVfTElNSVR9IG1lc3NhZ2VzIGhhcyBiZWVuIHJlYWNoZWQuYCk7XG4gIH1cblxuICB0aGlzLl9xdWV1ZWRNZXNzYWdlcy5wdXNoKGNyZWF0ZUV2ZW50TG9nLmJpbmQodGhpcykobXNnKSk7XG5cbiAgaWYgKCF0aGlzLl9wcm9jZXNzaW5nUXVldWUpIHtcbiAgICB0aGlzLl9wcm9jZXNzUXVldWUoKTtcbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiBwcm9jZXNzUXVldWUoKSB7XG4gIHRoaXMuX3Byb2Nlc3NpbmdRdWV1ZSA9IHRydWU7XG5cbiAgaWYgKCF0aGlzLl9jb25uZWN0ZWQpIHtcbiAgICBhd2FpdCB3YWl0Rm9yQ29ubmVjdGlvbk9wZW4uYmluZCh0aGlzKSgpO1xuICB9XG5cbiAgd2hpbGUgKHRoaXMuX3F1ZXVlZE1lc3NhZ2VzLmxlbmd0aCA+IDApIHtcbiAgICAvLyBzbWFsbCB3YWl0IHRvIGFsbG93IHJlc3BvbnNlIGZyb20gc2VydmVyIHRvIHRha2UgYWZmZWN0XG4gICAgYXdhaXQgd2FpdCgxKTtcblxuICAgIGlmICh0aGlzLl93YWl0VG9SZXRyeSAhPT0gbnVsbCkge1xuICAgICAgLy8gaGF2ZSBiZWVuIHJhdGUgbGltaXRlZCBzbyB3YWl0XG4gICAgICBhd2FpdCB0aGlzLl93YWl0VG9SZXRyeTtcbiAgICAgIHRoaXMuX3dhaXRUb1JldHJ5ID0gbnVsbDtcbiAgICB9XG5cbiAgICBjb25zdCBtc2cgPSB0aGlzLl9xdWV1ZWRNZXNzYWdlcy5zaGlmdCgpO1xuXG4gICAgY29uc3QgZGVsYXkgPSB0aGlzLl9saW1pdFJ1bGVzLmR1cmF0aW9uIC8gdGhpcy5fbGltaXRSdWxlcy5wb2ludHMgKiAxMDAwO1xuICAgIGF3YWl0IHdhaXQoZGVsYXkpO1xuXG4gICAgdGhpcy5fc29ja2V0LnNlbmQobXNnKTtcbiAgfVxuXG4gIHRoaXMuX3Byb2Nlc3NpbmdRdWV1ZSA9IGZhbHNlO1xuICB0aGlzLl9saW1pdFJ1bGVzID0gREVGQVVMVF9SQVRFX0xJTUlUX1JVTEVTO1xufVxuXG5mdW5jdGlvbiBoYW5kbGVNZXNzYWdlKG1zZykge1xuICBjb25zdCB7XG4gICAgc3RhdHVzLFxuICAgIHJlYXNvbixcbiAgICBldmVudCxcbiAgICBjb25uZWN0aW9uSWQsXG4gICAgc2VydmVyVmVyc2lvbixcbiAgICByZXRyeU1zLFxuICAgIGxpbWl0UnVsZXMsXG4gICAgYmxvY2tlZE1zZyxcbiAgICBkaXNwYXRjaFRpbWVzdGFtcFxuICB9ID0gSlNPTi5wYXJzZShtc2cuZGF0YSk7XG5cbiAgaWYgKGNvbm5lY3Rpb25JZCkge1xuICAgIGlmIChpc0xvY2FsU3RvcmFnZUF2YWlsYWJsZSgpKSB7XG4gICAgICB3aW5kb3cubG9jYWxTdG9yYWdlLnNldEl0ZW0odGhpcy5fc3RvcmFnZUtleSwgY29ubmVjdGlvbklkKTtcbiAgICB9XG5cbiAgICB0aGlzLl9jb25uZWN0aW9uSWQgPSBjb25uZWN0aW9uSWQ7XG4gIH0gLy8gaGFuZGxlIGFueSBlcnJvcnMgZnJvbSB0aGUgc2VydmVyXG5cblxuICBpZiAoc3RhdHVzID09PSAnZXJyb3InKSB7XG4gICAgaWYgKHJlYXNvbi5pbmNsdWRlcygncmF0ZWxpbWl0JykgJiYgIXJlYXNvbi5tYXRjaCgvSVAgKFBlbmRpbmdTaW11bGF0aW9ufE5vdGlmaWNhdGlvbikgcmF0ZWxpbWl0IHJlYWNoZWQvKSkge1xuICAgICAgdGhpcy5fd2FpdFRvUmV0cnkgPSB3YWl0KHJldHJ5TXMpO1xuICAgICAgdGhpcy5fbGltaXRSdWxlcyA9IGxpbWl0UnVsZXM7IC8vIGFkZCBibG9ja2VkIG1zZyB0byB0aGUgZnJvbnQgb2YgdGhlIHF1ZXVlXG5cbiAgICAgIGJsb2NrZWRNc2cgJiYgdGhpcy5fcXVldWVkTWVzc2FnZXMudW5zaGlmdChibG9ja2VkTXNnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAocmVhc29uLmluY2x1ZGVzKCd1cGdyYWRlIHlvdXIgcGxhbicpKSB7XG4gICAgICBpZiAodGhpcy5fb25lcnJvcikge1xuICAgICAgICB0aGlzLl9vbmVycm9yKHtcbiAgICAgICAgICBtZXNzYWdlOiByZWFzb25cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHJlYXNvbik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHJlYXNvbi5pbmNsdWRlcygnbm90IGEgdmFsaWQgQVBJIGtleScpKSB7XG4gICAgICBpZiAodGhpcy5fb25lcnJvcikge1xuICAgICAgICB0aGlzLl9vbmVycm9yKHtcbiAgICAgICAgICBtZXNzYWdlOiByZWFzb25cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHJlYXNvbik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHJlYXNvbi5pbmNsdWRlcygnbmV0d29yayBub3Qgc3VwcG9ydGVkJykpIHtcbiAgICAgIGlmICh0aGlzLl9vbmVycm9yKSB7XG4gICAgICAgIHRoaXMuX29uZXJyb3Ioe1xuICAgICAgICAgIG1lc3NhZ2U6IHJlYXNvblxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IocmVhc29uKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocmVhc29uLmluY2x1ZGVzKCdtYXhpbXVtIGFsbG93ZWQgYW1vdW50JykpIHtcbiAgICAgIGlmICh0aGlzLl9vbmVycm9yKSB7XG4gICAgICAgIHRoaXMuX29uZXJyb3Ioe1xuICAgICAgICAgIG1lc3NhZ2U6IHJlYXNvblxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IocmVhc29uKTtcbiAgICAgIH1cbiAgICB9IC8vIGhhbmRsZSBiaXRjb2luIHR4aWQgZXJyb3JcblxuXG4gICAgaWYgKHJlYXNvbi5pbmNsdWRlcygnaW52YWxpZCB0eGlkJykpIHtcbiAgICAgIGNvbnN0IHJlYXNvbiA9IGAke2V2ZW50LnRyYW5zYWN0aW9uLnR4aWR9IGlzIGFuIGludmFsaWQgdHhpZGA7XG5cbiAgICAgIGlmICh0aGlzLl9vbmVycm9yKSB7XG4gICAgICAgIHRoaXMuX29uZXJyb3Ioe1xuICAgICAgICAgIG1lc3NhZ2U6IHJlYXNvbixcbiAgICAgICAgICB0cmFuc2FjdGlvbjogZXZlbnQudHJhbnNhY3Rpb24udHhpZFxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IocmVhc29uKTtcbiAgICAgIH1cbiAgICB9IC8vIGhhbmRsZSBldGhlcmV1bSB0cmFuc2FjdGlvbiBoYXNoIGVycm9yXG5cblxuICAgIGlmIChyZWFzb24uaW5jbHVkZXMoJ2ludmFsaWQgaGFzaCcpKSB7XG4gICAgICBjb25zdCByZWFzb24gPSBgJHtldmVudC50cmFuc2FjdGlvbi5oYXNofSBpcyBhbiBpbnZhbGlkIHRyYW5zYWN0aW9uIGhhc2hgO1xuXG4gICAgICBpZiAodGhpcy5fb25lcnJvcikge1xuICAgICAgICB0aGlzLl9vbmVycm9yKHtcbiAgICAgICAgICBtZXNzYWdlOiByZWFzb24sXG4gICAgICAgICAgdHJhbnNhY3Rpb246IGV2ZW50LnRyYW5zYWN0aW9uLmhhc2hcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHJlYXNvbik7XG4gICAgICB9XG4gICAgfSAvLyBoYW5kbGUgZ2VuZXJhbCBhZGRyZXNzIGVycm9yXG5cblxuICAgIGlmIChyZWFzb24uaW5jbHVkZXMoJ2ludmFsaWQgYWRkcmVzcycpKSB7XG4gICAgICBjb25zdCByZWFzb24gPSBgJHtldmVudC5hY2NvdW50LmFkZHJlc3N9IGlzIGFuIGludmFsaWQgYWRkcmVzc2A7XG5cbiAgICAgIGlmICh0aGlzLl9vbmVycm9yKSB7XG4gICAgICAgIHRoaXMuX29uZXJyb3Ioe1xuICAgICAgICAgIG1lc3NhZ2U6IHJlYXNvbixcbiAgICAgICAgICBhY2NvdW50OiBldmVudC5hY2NvdW50LmFkZHJlc3NcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHJlYXNvbik7XG4gICAgICB9XG4gICAgfSAvLyBoYW5kbGUgYml0Y29pbiBzcGVjaWZpYyBhZGRyZXNzIGVycm9yXG5cblxuICAgIGlmIChyZWFzb24uaW5jbHVkZXMoJ25vdCBhIHZhbGlkIEJpdGNvaW4nKSkge1xuICAgICAgaWYgKHRoaXMuX29uZXJyb3IpIHtcbiAgICAgICAgdGhpcy5fb25lcnJvcih7XG4gICAgICAgICAgbWVzc2FnZTogcmVhc29uLFxuICAgICAgICAgIGFjY291bnQ6IGV2ZW50LmFjY291bnQuYWRkcmVzc1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IocmVhc29uKTtcbiAgICAgIH1cbiAgICB9IC8vIGhhbmRsZSBldGhlcmV1bSBzcGVjaWZpYyBhZGRyZXNzIGVycm9yXG5cblxuICAgIGlmIChyZWFzb24uaW5jbHVkZXMoJ25vdCBhIHZhbGlkIEV0aGVyZXVtJykpIHtcbiAgICAgIGlmICh0aGlzLl9vbmVycm9yKSB7XG4gICAgICAgIHRoaXMuX29uZXJyb3Ioe1xuICAgICAgICAgIG1lc3NhZ2U6IHJlYXNvbixcbiAgICAgICAgICBhY2NvdW50OiBldmVudC5hY2NvdW50LmFkZHJlc3NcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHJlYXNvbik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGV2ZW50ICYmIGV2ZW50LmNhdGVnb3J5Q29kZSA9PT0gJ3NpbXVsYXRlJykge1xuICAgICAgc2ltdWxhdGlvbnMkLmVycm9yKHtcbiAgICAgICAgZXZlbnRJZDogZXZlbnQuZXZlbnRJZCxcbiAgICAgICAgZXJyb3I6IHtcbiAgICAgICAgICBtZXNzYWdlOiByZWFzb25cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBoYW5kbGUgY29uZmlnIGVycm9yXG5cblxuICAgIGlmIChldmVudCAmJiBldmVudC5jb25maWcpIHtcbiAgICAgIGNvbnN0IGNvbmZpZ3VyYXRpb24gPSB0aGlzLmNvbmZpZ3VyYXRpb25zLmdldChldmVudC5jb25maWcuc2NvcGUpO1xuXG4gICAgICBpZiAoY29uZmlndXJhdGlvbiAmJiBjb25maWd1cmF0aW9uLnN1YnNjcmlwdGlvbikge1xuICAgICAgICBjb25maWd1cmF0aW9uLnN1YnNjcmlwdGlvbi5lcnJvcih7XG4gICAgICAgICAgbWVzc2FnZTogcmVhc29uXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm47XG4gICAgfSAvLyB0aHJvdyBlcnJvciB0aGF0IGNvbWVzIGJhY2sgZnJvbSB0aGUgc2VydmVyIHdpdGhvdXQgZm9ybWF0dGluZyB0aGUgbWVzc2FnZVxuXG5cbiAgICBpZiAodGhpcy5fb25lcnJvcikge1xuICAgICAgdGhpcy5fb25lcnJvcih7XG4gICAgICAgIG1lc3NhZ2U6IHJlYXNvblxuICAgICAgfSk7XG5cbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHJlYXNvbik7XG4gICAgfVxuICB9XG5cbiAgaWYgKGV2ZW50ICYmIGV2ZW50LmNvbmZpZykge1xuICAgIGNvbnN0IGNhc2VkU2NvcGUgPSB0aGlzLl9zeXN0ZW0gPT09ICdldGhlcmV1bScgPyBldmVudC5jb25maWcuc2NvcGUudG9Mb3dlckNhc2UoKSA6IGV2ZW50LmNvbmZpZy5zY29wZTtcbiAgICBjb25zdCBjb25maWd1cmF0aW9uID0gdGhpcy5jb25maWd1cmF0aW9ucy5nZXQoY2FzZWRTY29wZSk7XG5cbiAgICBpZiAoY29uZmlndXJhdGlvbiAmJiBjb25maWd1cmF0aW9uLnN1YnNjcmlwdGlvbikge1xuICAgICAgY29uZmlndXJhdGlvbi5zdWJzY3JpcHRpb24ubmV4dCgpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChldmVudCAmJiBldmVudC50cmFuc2FjdGlvbikge1xuICAgIGNvbnN0IHtcbiAgICAgIGV2ZW50SWQsXG4gICAgICB0cmFuc2FjdGlvbixcbiAgICAgIGV2ZW50Q29kZSxcbiAgICAgIGNvbnRyYWN0Q2FsbCxcbiAgICAgIHRpbWVTdGFtcCxcbiAgICAgIGJsb2NrY2hhaW46IHtcbiAgICAgICAgc3lzdGVtLFxuICAgICAgICBuZXR3b3JrXG4gICAgICB9XG4gICAgfSA9IGV2ZW50OyAvLyBmbGF0dGVuIGluIHRvIG9uZSBvYmplY3RcblxuICAgIGNvbnN0IG5ld1N0YXRlID0gdGhpcy5fc3lzdGVtID09PSAnZXRoZXJldW0nID8geyAuLi50cmFuc2FjdGlvbixcbiAgICAgIHNlcnZlclZlcnNpb24sXG4gICAgICBldmVudENvZGUsXG4gICAgICB0aW1lU3RhbXAsXG4gICAgICBkaXNwYXRjaFRpbWVzdGFtcCxcbiAgICAgIHN5c3RlbSxcbiAgICAgIG5ldHdvcmssXG4gICAgICBjb250cmFjdENhbGxcbiAgICB9IDogeyAuLi50cmFuc2FjdGlvbixcbiAgICAgIHNlcnZlclZlcnNpb24sXG4gICAgICBldmVudENvZGUsXG4gICAgICB0aW1lU3RhbXAsXG4gICAgICBkaXNwYXRjaFRpbWVzdGFtcCxcbiAgICAgIHN5c3RlbSxcbiAgICAgIG5ldHdvcmtcbiAgICB9OyAvLyBpZ25vcmUgc2VydmVyIGVjaG8gYW5kIHVuc3Vic2NyaWJlIG1lc3NhZ2VzXG5cbiAgICBpZiAoc2VydmVyRWNobyhldmVudENvZGUpIHx8IHRyYW5zYWN0aW9uLnN0YXR1cyA9PT0gJ3Vuc3Vic2NyaWJlZCcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIHJlcGxhY2Ugb3JpZ2luYWxIYXNoIHRvIG1hdGNoIHdlYmhvb2sgQVBJXG5cblxuICAgIGlmIChuZXdTdGF0ZS5vcmlnaW5hbEhhc2gpIHtcbiAgICAgIG5ld1N0YXRlLnJlcGxhY2VIYXNoID0gbmV3U3RhdGUuaGFzaDtcbiAgICAgIG5ld1N0YXRlLmhhc2ggPSBuZXdTdGF0ZS5vcmlnaW5hbEhhc2g7XG4gICAgICBkZWxldGUgbmV3U3RhdGUub3JpZ2luYWxIYXNoO1xuICAgIH0gLy8gcmVwbGFjZSBzdGF0dXMgdG8gbWF0Y2ggd2ViaG9vayBBUElcblxuXG4gICAgaWYgKGV2ZW50Q29kZSA9PT0gJ3R4U3BlZWRVcCcgJiYgbmV3U3RhdGUuc3RhdHVzICE9PSAnc3BlZWR1cCcpIHtcbiAgICAgIG5ld1N0YXRlLnN0YXR1cyA9ICdzcGVlZHVwJztcbiAgICB9IC8vIHJlcGxhY2Ugc3RhdHVzIHRvIG1hdGNoIHdlYmhvb2sgQVBJXG5cblxuICAgIGlmIChldmVudENvZGUgPT09ICd0eENhbmNlbCcgJiYgbmV3U3RhdGUuc3RhdHVzICE9PSAnY2FuY2VsJykge1xuICAgICAgbmV3U3RhdGUuc3RhdHVzID0gJ2NhbmNlbCc7XG4gICAgfSAvLyBoYW5kbGUgY2hhbmdlIG9mIGhhc2ggaW4gc3BlZWR1cCBhbmQgY2FuY2VsIGV2ZW50c1xuXG5cbiAgICBpZiAoZXZlbnRDb2RlID09PSAndHhTcGVlZFVwJyB8fCBldmVudENvZGUgPT09ICd0eENhbmNlbCcpIHtcbiAgICAgIHRoaXMud2F0Y2hlZFRyYW5zYWN0aW9ucyA9IHRoaXMud2F0Y2hlZFRyYW5zYWN0aW9ucy5tYXAodHggPT4ge1xuICAgICAgICBpZiAodHguaGFzaCA9PT0gbmV3U3RhdGUucmVwbGFjZUhhc2gpIHtcbiAgICAgICAgICAvLyByZWFzc2lnbiBoYXNoIHBhcmFtZXRlciBpbiB0cmFuc2FjdGlvbiBxdWV1ZSB0byBuZXcgaGFzaCBvciB0eGlkXG4gICAgICAgICAgdHguaGFzaCA9IHRyYW5zYWN0aW9uLmhhc2ggfHwgdHJhbnNhY3Rpb24udHhpZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0eDtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChldmVudCAmJiBldmVudC5jYXRlZ29yeUNvZGUgPT09ICdzaW11bGF0ZScpIHtcbiAgICAgIG5ld1N0YXRlLmNvbnRyYWN0Q2FsbCA9IGV2ZW50LnRyYW5zYWN0aW9uLmNvbnRyYWN0Q2FsbDtcbiAgICAgIGRlbGV0ZSBuZXdTdGF0ZS5kaXNwYXRjaFRpbWVzdGFtcDtcbiAgICAgIHNpbXVsYXRpb25zJC5uZXh0KHtcbiAgICAgICAgZXZlbnRJZCxcbiAgICAgICAgdHJhbnNhY3Rpb246IG5ld1N0YXRlXG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCB3YXRjaGVkQWRkcmVzcyA9IHRyYW5zYWN0aW9uLndhdGNoZWRBZGRyZXNzICYmIHRoaXMuX3N5c3RlbSA9PT0gJ2V0aGVyZXVtJyA/IHRyYW5zYWN0aW9uLndhdGNoZWRBZGRyZXNzLnRvTG93ZXJDYXNlKCkgOiB0cmFuc2FjdGlvbi53YXRjaGVkQWRkcmVzcztcblxuICAgIGlmICh3YXRjaGVkQWRkcmVzcykge1xuICAgICAgY29uc3QgYWNjb3VudE9iaiA9IHRoaXMud2F0Y2hlZEFjY291bnRzLmZpbmQoYWMgPT4gYWMuYWRkcmVzcyA9PT0gd2F0Y2hlZEFkZHJlc3MpO1xuICAgICAgY29uc3QgYWNjb3VudEVtaXR0ZXJSZXN1bHQgPSBhY2NvdW50T2JqID8gbGFzdChhY2NvdW50T2JqLmVtaXR0ZXJzLm1hcChlbWl0dGVyID0+IGVtaXR0ZXIuZW1pdChuZXdTdGF0ZSkpKSA6IGZhbHNlO1xuICAgICAgY29uc3QgY29uZmlndXJhdGlvbiA9IHRoaXMuY29uZmlndXJhdGlvbnMuZ2V0KHdhdGNoZWRBZGRyZXNzKTtcbiAgICAgIGNvbnN0IGVtaXR0ZXJSZXN1bHQgPSBjb25maWd1cmF0aW9uICYmIGNvbmZpZ3VyYXRpb24uZW1pdHRlciA/IGNvbmZpZ3VyYXRpb24uZW1pdHRlci5lbWl0KG5ld1N0YXRlKSB8fCBhY2NvdW50RW1pdHRlclJlc3VsdCA6IGFjY291bnRFbWl0dGVyUmVzdWx0O1xuXG4gICAgICB0aGlzLl90cmFuc2FjdGlvbkhhbmRsZXJzLmZvckVhY2goaGFuZGxlciA9PiBoYW5kbGVyKHtcbiAgICAgICAgdHJhbnNhY3Rpb246IG5ld1N0YXRlLFxuICAgICAgICBlbWl0dGVyUmVzdWx0XG4gICAgICB9KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHRyYW5zYWN0aW9uT2JqID0gdGhpcy53YXRjaGVkVHJhbnNhY3Rpb25zLmZpbmQodHggPT4gdHguaGFzaCA9PT0gbmV3U3RhdGUuaGFzaCB8fCBuZXdTdGF0ZS50eGlkKTtcbiAgICAgIGNvbnN0IGVtaXR0ZXJSZXN1bHQgPSB0cmFuc2FjdGlvbk9iaiAmJiB0cmFuc2FjdGlvbk9iai5lbWl0dGVyLmVtaXQobmV3U3RhdGUpO1xuXG4gICAgICB0aGlzLl90cmFuc2FjdGlvbkhhbmRsZXJzLmZvckVhY2goaGFuZGxlciA9PiBoYW5kbGVyKHtcbiAgICAgICAgdHJhbnNhY3Rpb246IG5ld1N0YXRlLFxuICAgICAgICBlbWl0dGVyUmVzdWx0XG4gICAgICB9KSk7IC8vIHJlcGxhY2UgdGhlIGVtaXR0ZXIgaGFzaCB0byB0aGUgcmVwbGFjZSBoYXNoIG9uIHJlcGxhY2VtZW50IHR4c1xuXG5cbiAgICAgIGlmIChuZXdTdGF0ZS5zdGF0dXMgPT09ICdzcGVlZHVwJyB8fCBuZXdTdGF0ZS5zdGF0dXMgPT09ICdjYW5jZWwnKSB7XG4gICAgICAgIHRoaXMud2F0Y2hlZFRyYW5zYWN0aW9ucyA9IHRoaXMud2F0Y2hlZFRyYW5zYWN0aW9ucy5tYXAodHggPT4ge1xuICAgICAgICAgIGlmICh0eC5oYXNoID09PSBuZXdTdGF0ZS5oYXNoIHx8IG5ld1N0YXRlLnR4aWQpIHtcbiAgICAgICAgICAgIHJldHVybiB7IC4uLnR4LFxuICAgICAgICAgICAgICBoYXNoOiBuZXdTdGF0ZS5yZXBsYWNlSGFzaFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gdHg7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVFdmVudExvZyhtc2cpIHtcbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHtcbiAgICB0aW1lU3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICBkYXBwSWQ6IHRoaXMuX2RhcHBJZCxcbiAgICB2ZXJzaW9uLFxuICAgIGFwcE5hbWU6IHRoaXMuX2FwcE5hbWUsXG4gICAgYXBwVmVyc2lvbjogdGhpcy5fYXBwVmVyc2lvbixcbiAgICBibG9ja2NoYWluOiB7XG4gICAgICBzeXN0ZW06IHRoaXMuX3N5c3RlbSxcbiAgICAgIG5ldHdvcms6IG5ldHdvcmtOYW1lKHRoaXMuX3N5c3RlbSwgdGhpcy5fbmV0d29ya0lkKSB8fCAnbG9jYWwnXG4gICAgfSxcbiAgICAuLi5tc2dcbiAgfSwgbXNnLmNhdGVnb3J5Q29kZSA9PT0gJ2NvbmZpZ3MnID8ganNvblByZXNlcnZlVW5kZWZpbmVkIDogdW5kZWZpbmVkKTtcbn1cblxuZnVuY3Rpb24gd2FpdEZvckNvbm5lY3Rpb25PcGVuKCkge1xuICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgY29uc3QgaW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICBpZiAodGhpcy5fY29ubmVjdGVkKSB7XG4gICAgICAgIHNldFRpbWVvdXQocmVzb2x2ZSwgMTAwKTtcbiAgICAgICAgY2xlYXJJbnRlcnZhbChpbnRlcnZhbCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufVxuXG5jb25zdCBERUZBVUxUX0FQUF9OQU1FID0gJ3Vua25vd24nO1xuY29uc3QgREVGQVVMVF9BUFBfVkVSU0lPTiA9ICd1bmtub3duJztcbmNvbnN0IERFRkFVTFRfU1lTVEVNID0gJ2V0aGVyZXVtJztcblxuY2xhc3MgU0RLIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHZhbGlkYXRlT3B0aW9ucyhvcHRpb25zKTtcbiAgICBjb25zdCB7XG4gICAgICBzeXN0ZW0gPSBERUZBVUxUX1NZU1RFTSxcbiAgICAgIG5hbWUgPSBERUZBVUxUX0FQUF9OQU1FLFxuICAgICAgYXBwVmVyc2lvbiA9IERFRkFVTFRfQVBQX1ZFUlNJT04sXG4gICAgICBuZXR3b3JrSWQsXG4gICAgICB0cmFuc2FjdGlvbkhhbmRsZXJzID0gW10sXG4gICAgICB3cyxcbiAgICAgIG9ub3BlbixcbiAgICAgIG9uZG93bixcbiAgICAgIG9ucmVvcGVuLFxuICAgICAgb25lcnJvcixcbiAgICAgIG9uY2xvc2VcbiAgICB9ID0gb3B0aW9ucztcbiAgICBjb25zdCB7XG4gICAgICBhcGlVcmxcbiAgICB9ID0gb3B0aW9ucztcbiAgICBjb25zdCB7XG4gICAgICBkYXBwSWRcbiAgICB9ID0gb3B0aW9uczsgLy8gb3ZlcnJpZGUgZGVmYXVsdCB0aW1lb3V0IHRvIGFsbG93IGZvciBzbG93IGNvbm5lY3Rpb25zXG5cbiAgICBjb25zdCB0aW1lb3V0ID0ge1xuICAgICAgY29ubmVjdFRpbWVvdXQ6IDEwMDAwXG4gICAgfTtcbiAgICBjb25zdCBzb2NrZXQgPSBuZXcgU3R1cmR5V2ViU29ja2V0KGFwaVVybCB8fCAnd3NzOi8vYXBpLmJsb2NrbmF0aXZlLmNvbS92MCcsIHdzID8ge1xuICAgICAgd3NDb25zdHJ1Y3Rvcjogd3MsXG4gICAgICAuLi50aW1lb3V0XG4gICAgfSA6IHsgLi4udGltZW91dFxuICAgIH0pO1xuICAgIHNvY2tldC5vbm9wZW4gPSBvbk9wZW4uYmluZCh0aGlzLCBvbm9wZW4pO1xuICAgIHNvY2tldC5vbmRvd24gPSBvbkRvd24uYmluZCh0aGlzLCBvbmRvd24pO1xuICAgIHNvY2tldC5vbnJlb3BlbiA9IG9uUmVvcGVuLmJpbmQodGhpcywgb25yZW9wZW4pO1xuICAgIHNvY2tldC5vbm1lc3NhZ2UgPSBoYW5kbGVNZXNzYWdlLmJpbmQodGhpcyk7XG5cbiAgICBzb2NrZXQub25lcnJvciA9IGVycm9yID0+IG9uZXJyb3IgJiYgb25lcnJvcih7XG4gICAgICBtZXNzYWdlOiAnVGhlcmUgd2FzIGEgV2ViU29ja2V0IGVycm9yJyxcbiAgICAgIGVycm9yXG4gICAgfSk7XG5cbiAgICBzb2NrZXQub25jbG9zZSA9ICgpID0+IHtcbiAgICAgIHRoaXMuX3BpbmdUaW1lb3V0ICYmIGNsZWFySW50ZXJ2YWwodGhpcy5fcGluZ1RpbWVvdXQpO1xuICAgICAgb25jbG9zZSAmJiBvbmNsb3NlKCk7XG4gICAgfTtcblxuICAgIGNvbnN0IHN0b3JhZ2VLZXkgPSBDcnlwdG9Fcy5TSEExKGAke2RhcHBJZH0gLSAke25hbWV9YCkudG9TdHJpbmcoKTtcbiAgICBjb25zdCBzdG9yZWRDb25uZWN0aW9uSWQgPSBpc0xvY2FsU3RvcmFnZUF2YWlsYWJsZSgpICYmIHdpbmRvdy5sb2NhbFN0b3JhZ2UuZ2V0SXRlbShzdG9yYWdlS2V5KTtcbiAgICB0aGlzLl9zdG9yYWdlS2V5ID0gc3RvcmFnZUtleTtcbiAgICB0aGlzLl9jb25uZWN0aW9uSWQgPSBzdG9yZWRDb25uZWN0aW9uSWQgfHwgdW5kZWZpbmVkO1xuICAgIHRoaXMuX2RhcHBJZCA9IGRhcHBJZDtcbiAgICB0aGlzLl9zeXN0ZW0gPSBzeXN0ZW07XG4gICAgdGhpcy5fbmV0d29ya0lkID0gbmV0d29ya0lkO1xuICAgIHRoaXMuX2FwcE5hbWUgPSBuYW1lO1xuICAgIHRoaXMuX2FwcFZlcnNpb24gPSBhcHBWZXJzaW9uO1xuICAgIHRoaXMuX3RyYW5zYWN0aW9uSGFuZGxlcnMgPSB0cmFuc2FjdGlvbkhhbmRsZXJzO1xuICAgIHRoaXMuX3NvY2tldCA9IHNvY2tldDtcbiAgICB0aGlzLl9jb25uZWN0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9zZW5kTWVzc2FnZSA9IHNlbmRNZXNzYWdlLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fcGluZ1RpbWVvdXQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fZGVzdHJveWVkID0gZmFsc2U7XG4gICAgdGhpcy5fb25lcnJvciA9IG9uZXJyb3I7XG4gICAgdGhpcy5fcXVldWVkTWVzc2FnZXMgPSBbXTtcbiAgICB0aGlzLl9saW1pdFJ1bGVzID0gREVGQVVMVF9SQVRFX0xJTUlUX1JVTEVTO1xuICAgIHRoaXMuX3dhaXRUb1JldHJ5ID0gbnVsbDtcbiAgICB0aGlzLl9wcm9jZXNzaW5nUXVldWUgPSBmYWxzZTtcbiAgICB0aGlzLl9wcm9jZXNzUXVldWUgPSBwcm9jZXNzUXVldWUuYmluZCh0aGlzKTtcblxuICAgIGlmICh0aGlzLl9zb2NrZXQud3Mub24pIHtcbiAgICAgIHRoaXMuX2hlYXJ0YmVhdCA9ICgpID0+IHtcbiAgICAgICAgdGhpcy5fcGluZ1RpbWVvdXQgJiYgY2xlYXJUaW1lb3V0KHRoaXMuX3BpbmdUaW1lb3V0KTtcbiAgICAgICAgdGhpcy5fcGluZ1RpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAvLyB0ZXJtaW5hdGUgY29ubmVjdGlvbiBpZiB3ZSBoYXZlbid0IGhlYXJkIHRoZSBzZXJ2ZXIgcGluZyBhZnRlciBzZXJ2ZXIgdGltZW91dCBwbHVzIGNvbnNlcnZhdGl2ZSBsYXRlbmN5IGRlbGF5XG4gICAgICAgICAgLy8gU3R1cmR5IFdlYnNvY2tldCB3aWxsIGhhbmRsZSB0aGUgbmV3IGNvbm5lY3Rpb24gbG9naWNcbiAgICAgICAgICB0aGlzLl9zb2NrZXQud3MudGVybWluYXRlKCk7XG4gICAgICAgIH0sIDMwMDAwICsgMTAwMCk7XG4gICAgICB9O1xuXG4gICAgICB0aGlzLl9zb2NrZXQud3Mub24oJ3BpbmcnLCAoKSA9PiB7XG4gICAgICAgIHRoaXMuX2hlYXJ0YmVhdCAmJiB0aGlzLl9oZWFydGJlYXQoKTtcbiAgICAgIH0pO1xuICAgIH0gLy8gcHVibGljIEFQSVxuXG5cbiAgICB0aGlzLndhdGNoZWRUcmFuc2FjdGlvbnMgPSBbXTtcbiAgICB0aGlzLndhdGNoZWRBY2NvdW50cyA9IFtdO1xuICAgIHRoaXMuY29uZmlndXJhdGlvbnMgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy50cmFuc2FjdGlvbiA9IHRyYW5zYWN0aW9uLmJpbmQodGhpcyk7XG4gICAgdGhpcy5hY2NvdW50ID0gYWNjb3VudC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuZXZlbnQgPSBldmVudC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuc2ltdWxhdGUgPSBzaW11bGF0ZS5iaW5kKHRoaXMpO1xuICAgIHRoaXMubXVsdGlTaW0gPSBtdWx0aVNpbS5iaW5kKHRoaXMpO1xuICAgIHRoaXMudW5zdWJzY3JpYmUgPSB1bnN1YnNjcmliZS5iaW5kKHRoaXMpO1xuICAgIHRoaXMuY29uZmlndXJhdGlvbiA9IGNvbmZpZ3VyYXRpb24uYmluZCh0aGlzKTtcblxuICAgIHRoaXMuZGVzdHJveSA9ICgpID0+IHtcbiAgICAgIHRoaXMuX3NvY2tldC5jbG9zZSgpO1xuXG4gICAgICB0aGlzLl9kZXN0cm95ZWQgPSB0cnVlOyAvLyBjYWxsIG9uY2xvc2UgbWFudWFsbHkgaGVyZSBhcyBTdHVyZHlXZWJTb2NrZXQgZG9lc24ndCBjdXJyZW50bHkgd29yayBhcyBleHBlY3RlZFxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2RwaGlsaXBzb24vc3R1cmR5LXdlYnNvY2tldC9pc3N1ZXMvNVxuXG4gICAgICB0aGlzLl9zb2NrZXQub25jbG9zZSgpO1xuICAgIH07XG4gIH1cblxuICBzdGF0aWMgbXVsdGljaGFpbihvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBNdWx0aUNoYWluKG9wdGlvbnMsIHRoaXMpO1xuICB9XG5cbn1cblxuZnVuY3Rpb24gb25PcGVuKGhhbmRsZXIpIHtcbiAgdGhpcy5fY29ubmVjdGVkID0gdHJ1ZTtcbiAgY29uc3QgbXNnID0ge1xuICAgIGNhdGVnb3J5Q29kZTogJ2luaXRpYWxpemUnLFxuICAgIGV2ZW50Q29kZTogJ2NoZWNrRGFwcElkJyxcbiAgICBjb25uZWN0aW9uSWQ6IHRoaXMuX2Nvbm5lY3Rpb25JZFxuICB9OyAvLyBzZW5kIHRoaXMgbWVzc2FnZSBkaXJlY3RseSByYXRoZXIgdGhhbiBwdXQgaW4gcXVldWVcblxuICB0aGlzLl9zb2NrZXQuc2VuZChjcmVhdGVFdmVudExvZy5iaW5kKHRoaXMpKG1zZykpO1xuXG4gIHRoaXMuX2hlYXJ0YmVhdCAmJiB0aGlzLl9oZWFydGJlYXQoKTtcbiAgaGFuZGxlciAmJiBoYW5kbGVyKCk7XG59XG5cbmZ1bmN0aW9uIG9uRG93bihoYW5kbGVyLCBjbG9zZUV2ZW50KSB7XG4gIHRoaXMuX2Nvbm5lY3RlZCA9IGZhbHNlO1xuXG4gIGlmIChoYW5kbGVyKSB7XG4gICAgaGFuZGxlcihjbG9zZUV2ZW50KTtcbiAgfVxuXG4gIHRoaXMuX3BpbmdUaW1lb3V0ICYmIGNsZWFyVGltZW91dCh0aGlzLl9waW5nVGltZW91dCk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIG9uUmVvcGVuKGhhbmRsZXIpIHtcbiAgdGhpcy5fY29ubmVjdGVkID0gdHJ1ZTtcbiAgY29uc3QgbXNnID0ge1xuICAgIGNhdGVnb3J5Q29kZTogJ2luaXRpYWxpemUnLFxuICAgIGV2ZW50Q29kZTogJ2NoZWNrRGFwcElkJyxcbiAgICBjb25uZWN0aW9uSWQ6IHRoaXMuX2Nvbm5lY3Rpb25JZFxuICB9O1xuXG4gIHRoaXMuX3NvY2tldC5zZW5kKGNyZWF0ZUV2ZW50TG9nLmJpbmQodGhpcykobXNnKSk7IC8vIHJlLXJlZ2lzdGVyIGFsbCBjb25maWd1cmF0aW9ucyBvbiByZS1jb25uZWN0aW9uXG5cblxuICBjb25zdCBjb25maWd1cmF0aW9ucyA9IEFycmF5LmZyb20odGhpcy5jb25maWd1cmF0aW9ucy52YWx1ZXMoKSk7IC8vIHJlZ2lzdGVyIGdsb2JhbCBjb25maWcgZmlyc3QgYW5kIHdhaXQgZm9yIGl0IHRvIGNvbXBsZXRlXG5cbiAgY29uc3QgZ2xvYmFsQ29uZmlndXJhdGlvbiA9IHRoaXMuY29uZmlndXJhdGlvbnMuZ2V0KCdnbG9iYWwnKTtcblxuICBpZiAoZ2xvYmFsQ29uZmlndXJhdGlvbikge1xuICAgIHRyeSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgICBjb25zdCB7XG4gICAgICAgIGVtaXR0ZXIsXG4gICAgICAgIHN1YnNjcmlwdGlvbixcbiAgICAgICAgLi4uY29uZmlnXG4gICAgICB9ID0gZ2xvYmFsQ29uZmlndXJhdGlvbjtcbiAgICAgIGF3YWl0IHRoaXMuY29uZmlndXJhdGlvbihjb25maWcpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ0Vycm9yIHJlLXNlbmRpbmcgZ2xvYmFsIGNvbmZpZ3VyYXRpb24gdXBvbiByZWNvbm5lY3Rpb246JywgZXJyb3IpO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGFkZHJlc3NDb25maWd1cmF0aW9ucyA9IGNvbmZpZ3VyYXRpb25zLmZpbHRlcigoe1xuICAgIHNjb3BlXG4gIH0pID0+IHNjb3BlICE9PSAnZ2xvYmFsJyk7XG4gIGFkZHJlc3NDb25maWd1cmF0aW9ucy5mb3JFYWNoKGVuaGFuY2VkQ29uZmlnID0+IHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgY29uc3Qge1xuICAgICAgZW1pdHRlcixcbiAgICAgIHN1YnNjcmlwdGlvbixcbiAgICAgIC4uLmNvbmZpZ1xuICAgIH0gPSBlbmhhbmNlZENvbmZpZztcblxuICAgIHRoaXMuX3NlbmRNZXNzYWdlKHtcbiAgICAgIGNhdGVnb3J5Q29kZTogJ2NvbmZpZ3MnLFxuICAgICAgZXZlbnRDb2RlOiAncHV0JyxcbiAgICAgIGNvbmZpZ1xuICAgIH0pO1xuICB9KTsgLy8gcmUtcmVnaXN0ZXIgYWxsIGFjY291bnRzIHRvIGJlIHdhdGNoZWQgYnkgc2VydmVyIHVwb25cbiAgLy8gcmUtY29ubmVjdGlvbiBhcyB0aGV5IGRvbid0IGdldCB0cmFuc2ZlcnJlZCBvdmVyIGF1dG9tYXRpY2FsbHlcbiAgLy8gdG8gdGhlIG5ldyBjb25uZWN0aW9uIGxpa2UgdHggaGFzaGVzIGRvXG5cbiAgdGhpcy53YXRjaGVkQWNjb3VudHMuZm9yRWFjaChhY2NvdW50ID0+IHtcbiAgICB0aGlzLl9zZW5kTWVzc2FnZSh7XG4gICAgICBldmVudENvZGU6ICdhY2NvdW50QWRkcmVzcycsXG4gICAgICBjYXRlZ29yeUNvZGU6ICd3YXRjaCcsXG4gICAgICBhY2NvdW50OiB7XG4gICAgICAgIGFkZHJlc3M6IGFjY291bnQuYWRkcmVzc1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcblxuICBpZiAoaGFuZGxlcikge1xuICAgIGhhbmRsZXIoKTtcbiAgfVxuXG4gIGlmICh0aGlzLl9zb2NrZXQud3MgJiYgdGhpcy5fc29ja2V0LndzLm9uKSB7XG4gICAgLy8gbmVlZCB0byByZS1yZWdpc3RlciBwaW5nIGV2ZW50IHNpbmNlIG5ldyBjb25uZWN0aW9uXG4gICAgdGhpcy5fc29ja2V0LndzLm9uKCdwaW5nJywgKCkgPT4ge1xuICAgICAgdGhpcy5faGVhcnRiZWF0ICYmIHRoaXMuX2hlYXJ0YmVhdCgpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5faGVhcnRiZWF0KCk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgU0RLO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/bnc-sdk/dist/esm/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/bnc-sdk/node_modules/nanoid/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/bnc-sdk/node_modules/nanoid/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   customAlphabet: () => (/* binding */ customAlphabet),\n/* harmony export */   customRandom: () => (/* binding */ customRandom),\n/* harmony export */   nanoid: () => (/* binding */ nanoid),\n/* harmony export */   random: () => (/* binding */ random),\n/* harmony export */   urlAlphabet: () => (/* reexport safe */ _url_alphabet_index_js__WEBPACK_IMPORTED_MODULE_1__.urlAlphabet)\n/* harmony export */ });\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! crypto */ \"crypto\");\n/* harmony import */ var _url_alphabet_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./url-alphabet/index.js */ \"(ssr)/./node_modules/bnc-sdk/node_modules/nanoid/url-alphabet/index.js\");\n\n\nconst POOL_SIZE_MULTIPLIER = 128\nlet pool, poolOffset\nlet fillPool = bytes => {\n  if (!pool || pool.length < bytes) {\n    pool = Buffer.allocUnsafe(bytes * POOL_SIZE_MULTIPLIER)\n    crypto__WEBPACK_IMPORTED_MODULE_0__.randomFillSync(pool)\n    poolOffset = 0\n  } else if (poolOffset + bytes > pool.length) {\n    crypto__WEBPACK_IMPORTED_MODULE_0__.randomFillSync(pool)\n    poolOffset = 0\n  }\n  poolOffset += bytes\n}\nlet random = bytes => {\n  fillPool((bytes -= 0))\n  return pool.subarray(poolOffset - bytes, poolOffset)\n}\nlet customRandom = (alphabet, defaultSize, getRandom) => {\n  let mask = (2 << (31 - Math.clz32((alphabet.length - 1) | 1))) - 1\n  let step = Math.ceil((1.6 * mask * defaultSize) / alphabet.length)\n  return (size = defaultSize) => {\n    let id = ''\n    while (true) {\n      let bytes = getRandom(step)\n      let i = step\n      while (i--) {\n        id += alphabet[bytes[i] & mask] || ''\n        if (id.length === size) return id\n      }\n    }\n  }\n}\nlet customAlphabet = (alphabet, size = 21) =>\n  customRandom(alphabet, size, random)\nlet nanoid = (size = 21) => {\n  fillPool((size -= 0))\n  let id = ''\n  for (let i = poolOffset - size; i < poolOffset; i++) {\n    id += _url_alphabet_index_js__WEBPACK_IMPORTED_MODULE_1__.urlAlphabet[pool[i] & 63]\n  }\n  return id\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYm5jLXNkay9ub2RlX21vZHVsZXMvbmFub2lkL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBMkI7QUFDMEI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksa0RBQXFCO0FBQ3pCO0FBQ0EsSUFBSTtBQUNKLElBQUksa0RBQXFCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLGdCQUFnQjtBQUNsRCxVQUFVLCtEQUFXO0FBQ3JCO0FBQ0E7QUFDQTtBQUNvRSIsInNvdXJjZXMiOlsid2VicGFjazovL2dpdGh1YnN0cmVhbWluZy8uL25vZGVfbW9kdWxlcy9ibmMtc2RrL25vZGVfbW9kdWxlcy9uYW5vaWQvaW5kZXguanM/NWU4MyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgY3J5cHRvIGZyb20gJ2NyeXB0bydcbmltcG9ydCB7IHVybEFscGhhYmV0IH0gZnJvbSAnLi91cmwtYWxwaGFiZXQvaW5kZXguanMnXG5jb25zdCBQT09MX1NJWkVfTVVMVElQTElFUiA9IDEyOFxubGV0IHBvb2wsIHBvb2xPZmZzZXRcbmxldCBmaWxsUG9vbCA9IGJ5dGVzID0+IHtcbiAgaWYgKCFwb29sIHx8IHBvb2wubGVuZ3RoIDwgYnl0ZXMpIHtcbiAgICBwb29sID0gQnVmZmVyLmFsbG9jVW5zYWZlKGJ5dGVzICogUE9PTF9TSVpFX01VTFRJUExJRVIpXG4gICAgY3J5cHRvLnJhbmRvbUZpbGxTeW5jKHBvb2wpXG4gICAgcG9vbE9mZnNldCA9IDBcbiAgfSBlbHNlIGlmIChwb29sT2Zmc2V0ICsgYnl0ZXMgPiBwb29sLmxlbmd0aCkge1xuICAgIGNyeXB0by5yYW5kb21GaWxsU3luYyhwb29sKVxuICAgIHBvb2xPZmZzZXQgPSAwXG4gIH1cbiAgcG9vbE9mZnNldCArPSBieXRlc1xufVxubGV0IHJhbmRvbSA9IGJ5dGVzID0+IHtcbiAgZmlsbFBvb2woKGJ5dGVzIC09IDApKVxuICByZXR1cm4gcG9vbC5zdWJhcnJheShwb29sT2Zmc2V0IC0gYnl0ZXMsIHBvb2xPZmZzZXQpXG59XG5sZXQgY3VzdG9tUmFuZG9tID0gKGFscGhhYmV0LCBkZWZhdWx0U2l6ZSwgZ2V0UmFuZG9tKSA9PiB7XG4gIGxldCBtYXNrID0gKDIgPDwgKDMxIC0gTWF0aC5jbHozMigoYWxwaGFiZXQubGVuZ3RoIC0gMSkgfCAxKSkpIC0gMVxuICBsZXQgc3RlcCA9IE1hdGguY2VpbCgoMS42ICogbWFzayAqIGRlZmF1bHRTaXplKSAvIGFscGhhYmV0Lmxlbmd0aClcbiAgcmV0dXJuIChzaXplID0gZGVmYXVsdFNpemUpID0+IHtcbiAgICBsZXQgaWQgPSAnJ1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBsZXQgYnl0ZXMgPSBnZXRSYW5kb20oc3RlcClcbiAgICAgIGxldCBpID0gc3RlcFxuICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICBpZCArPSBhbHBoYWJldFtieXRlc1tpXSAmIG1hc2tdIHx8ICcnXG4gICAgICAgIGlmIChpZC5sZW5ndGggPT09IHNpemUpIHJldHVybiBpZFxuICAgICAgfVxuICAgIH1cbiAgfVxufVxubGV0IGN1c3RvbUFscGhhYmV0ID0gKGFscGhhYmV0LCBzaXplID0gMjEpID0+XG4gIGN1c3RvbVJhbmRvbShhbHBoYWJldCwgc2l6ZSwgcmFuZG9tKVxubGV0IG5hbm9pZCA9IChzaXplID0gMjEpID0+IHtcbiAgZmlsbFBvb2woKHNpemUgLT0gMCkpXG4gIGxldCBpZCA9ICcnXG4gIGZvciAobGV0IGkgPSBwb29sT2Zmc2V0IC0gc2l6ZTsgaSA8IHBvb2xPZmZzZXQ7IGkrKykge1xuICAgIGlkICs9IHVybEFscGhhYmV0W3Bvb2xbaV0gJiA2M11cbiAgfVxuICByZXR1cm4gaWRcbn1cbmV4cG9ydCB7IG5hbm9pZCwgY3VzdG9tQWxwaGFiZXQsIGN1c3RvbVJhbmRvbSwgdXJsQWxwaGFiZXQsIHJhbmRvbSB9XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/bnc-sdk/node_modules/nanoid/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/bnc-sdk/node_modules/nanoid/url-alphabet/index.js":
/*!************************************************************************!*\
  !*** ./node_modules/bnc-sdk/node_modules/nanoid/url-alphabet/index.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   urlAlphabet: () => (/* binding */ urlAlphabet)\n/* harmony export */ });\nlet urlAlphabet =\n  'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict'\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYm5jLXNkay9ub2RlX21vZHVsZXMvbmFub2lkL3VybC1hbHBoYWJldC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNzQiIsInNvdXJjZXMiOlsid2VicGFjazovL2dpdGh1YnN0cmVhbWluZy8uL25vZGVfbW9kdWxlcy9ibmMtc2RrL25vZGVfbW9kdWxlcy9uYW5vaWQvdXJsLWFscGhhYmV0L2luZGV4LmpzP2MzOGEiXSwic291cmNlc0NvbnRlbnQiOlsibGV0IHVybEFscGhhYmV0ID1cbiAgJ3VzZWFuZG9tLTI2VDE5ODM0MFBYNzVweEpBQ0tWRVJZTUlOREJVU0hXT0xGX0dRWmJmZ2hqa2xxdnd5enJpY3QnXG5leHBvcnQgeyB1cmxBbHBoYWJldCB9XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/bnc-sdk/node_modules/nanoid/url-alphabet/index.js\n");

/***/ })

};
;